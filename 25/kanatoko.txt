x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 開発者のための正しいCSRF対策 ---

著者：金床

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　ウェブアプリケーション開発者の立場から見たCSRF対策について、さまざまな
情報が入り乱れている。筆者が2006年3月の時点において国内のウェブサイトやコ
ンピュータ書籍・雑誌などでCSRF対策について書かれている記事を調べた結果、
おどろくべきことに、そのほとんどが誤りを含んでいたり、現実的には使用でき
ない方法を紹介したりしていた。そこで本稿ではウェブアプリケーション開発者
にとっての本当に正しいCSRF対策についてまとめることとする。また、採用すべ
きでないCSRF対策とその理由も合わせて紹介する。


■0x02.) あらゆる機能がターゲットとなりうる

　ウェブアプリケーションの持つ全ての機能がCSRF攻撃の対象となりうる。まず
このことを認識しておく必要がある。

　AmazonのようなショッピングサイトやGoogleのような検索サイト、そしてはて
なダイアリーやMixiのような日記やブログを書くサイトなど、ウェブアプリケー
ションにはさまざまなものが存在する。そしてそれぞれのアプリケーションは細
かい「機能」の積み重ねによって成り立っている。

　例えばショッピングサイトは、次のような機能の集まりである。

・ログインする
・商品を検索する
・商品の情報を表示する
・商品をカートに入れる
・送り先の住所やクレジットカードの番号などを入力する
・確認のため注文内容を表示する
・精算を決定する
・ログアウトする

　現実のケースとしてCSRF攻撃の対象になるのは「商品をカートに入れる」など
の「攻撃者にとってうまみのある機能」であることが多いが、理論的にはアプリ
ケーションに存在する機能は全てCSRF攻撃の対象となりうる。CSRF対策を考える
上でまず行うべきことは「アプリケーションのうち、どの機能についてCSRF対策
を行うか」を決定することである。すべての機能について対策を施してもよいし、
重要と思われるいくつかの機能だけに絞って対策を行うという選択肢もあるだろ
う。

　「データベースを更新する機能のみCSRF対策をすればよい」のような考えは正
しくない。どの機能について対策を行うかは、ウェブアプリケーションの運営者
や開発者が決めるべきことである。


■0x03.) ひとつの機能は2画面で構成される

　それがどんな機能であれ、ひとつの機能は基本的には2画面で構成される。CSRF
対策を考える上で、このことをしっかり認識しておく必要がある。

　例としてまず「ログインする」という機能について考えてみる。ユーザーはロ
グインしたいサイトのトップページなどにアクセスする。するとブラウザにはユ
ーザーIDとパスワードの入力欄を持つ画面が表示される。これが「画面1」である。
次にユーザーはユーザーIDとパスワードを入力し、「ログイン」のボタンをクリ
ックする。するとブラウザには「ようこそ金床さん。」のようにログインに成功
したことを示す画面が表示される。これが「画面2」である。

　2つめの例として「日記を書く」という機能について考えてみる。ユーザは日記
を書くためのページへアクセスする。するとブラウザには日記を記入するための
テキスト入力欄を持つ画面が表示される。これが「画面1」である。ユーザはテキ
スト入力欄に日記を書き、「書き込む」というボタンをクリックする。するとブ
ラウザには「日記を書き込みました」などの画面が表示される。これが「画面2」
である。

　3つめの例として検索エンジンを使った「検索する」という機能について考えて
みる。ユーザーはGoogleやYahoo!などのサイトのトップページにアクセスする。
するとブラウザにはキーワード入力欄を持つ画面が表示される。これが「画面1」
である。次にユーザは検索したいキーワードを入力し、検索ボタンをクリックす
る。するとブラウザには検索結果が表示される。これが「画面2」である。

　最後の例として「ログアウトする」という機能について考えてみる。ユーザー
はすでにウェブアプリケーションにログイン済みである。そのため、ブラウザに
表示されている画面の隅には「ログアウトする」というリンクやボタンがある。
この画面が「画面1」である。ユーザが「ログアウトする」をクリックすると、「
ご利用ありがとうございました」などの画面が表示される。これが「画面2」であ
る。

　HTTPレベルで考えると、まず画面1を表示する際に一度リクエストとレスポンス
のやりとりが発生する。そして画面2を表示する際に、さらに一度リクエストとレ
スポンスがやりとりされる。これらをそれぞれ次のように呼ぶことにする。

・リクエスト1
・レスポンス1
・リクエスト2
・レスポンス2

　サーバー側に存在するプログラムは、リクエスト1を受信すると何かしらの処理
を行い、レスポンス1を送信する。また同様に、リクエスト2とレスポンス2の間に
も処理を行う。これらの処理をそれぞれ次のように呼ぶことにする。

・処理1
・処理2

　また、レスポンス1、レスポンス2によってブラウザに表示される画面をそれぞ
れ次のように呼ぶことにする。

・画面1
・画面2


■0x04.) 「CSRF以前の問題」については考えない

　CSRF対策を考える上で、非常識的な「CSRF以前の問題」が存在すると考えてい
ては話が先に進まない。「CSRF以前の問題」とは次のようなものだ。

・アプリケーションにXSS脆弱性が存在する
・攻撃者が正規ユーザのトラフィックを盗聴可能な状態である
・正規ユーザのマシンにスパイウェアが入りこんでいる
・正規ユーザが悪意あるプロキシサーバーを経由して通信している
・正規ユーザが催眠術で攻撃者に操られている

　このような仮定の下ではCSRF対策を議論する意味がない。以下の説明ではウェ
ブアプリケーションを取り巻く状況はごく常識的なものであるとする。


■0x05.) CSSXSS脆弱性を無視しない

　CSSXSS脆弱性はIE（Internet Explorer）に存在するバグである。これを悪用す
ると攻撃者が仕掛けた罠のページにレスポンス1のボディ部分の内容が読み込まれ、
hiddenフィールドに格納されたワンタイムトークンなどの値が攻撃者の手に落ち
ることがある。これは深刻なバグであるにも関わらずパッチがリリースされてお
らず、2006年3月の時点で既に数ヶ月もの間脆弱なままの状態が続いている。

　「いちいちウェブブラウザのバグを気にしていてはCSRF対策など行うことがで
きない。これはいわゆる（上の項で説明した）『CSRF以前の問題』なのではない
か」という意見はもっともだ。しかしIEは9割近いシェアを持っているため、この
バグを無視したCSRF対策を行っても、実際には1割の利用者しか保護できないとい
うことになる。あなたはウェブサイトの利用者に対して「私たちのサイトではCS
RF対策を行っています。しかしIEのバグについては関知しません。その結果とし
てIEの利用者に対してはCSRF攻撃が可能です」などと説明できるだろうか。

　せっかくCSRF対策を行おうとしているのだから、利用者全体に対して安全を提
供できるような方法を採るのがよいだろう。本稿ではこのような考えの元、 CSS
XSS脆弱性も考慮に入れてCSRF対策を行う。


■0x06.) 正しいCSRF対策

　それでは、筆者が安全だと考える具体的なCSRF対策について説明する。これら
の方法のうち、どれかひとつだけを採用すればよい。ここではCookieを利用した
セッション管理を行うアプリケーションを対象とする。ここで注意してほしいの
は、ユーザIDやパスワードを使ったいわゆる「ログイン」機能があるかないかは、
あまり重要ではないということだ。Cookieでセッション管理が行われているかぎ
り、CSRF対策は「ログイン」という概念の存在に左右されない。

　ちなみに、hiddenフィールドにセッションIDを格納し全ての画面遷移にPOSTを
用いるアプリケーションには、CSRF攻撃は通用しない。リクエスト1がPOSTであ
ることからCSSXSS脆弱性の影響も受けない。


■0x07.) 正しい対策その1: ワンタイムトークンを正しく使用する方法

　まずひとつめはワンタイムトークンを使う方法である。ここで題に「正しく使
用する方法」と付けたのには理由がある。ひとくちに「ワンタイムトークンを使
う」といっても開発者によって実装方法がまちまちであり、場合によってはCSRF
対策とならないワンタイムトークンの使い方をしてしまうことがあるのだ（後ほ
ど実例を挙げる）。そこでここでは押さえるべきポイントを明確にした、ワンタ
イムトークンの正しい使用方法を紹介する。

　まず、アプリケーションの作りとして、リクエスト1が必ずPOSTを用いるような
形にする。これによってCSSXSS脆弱性を利用したhiddenフィールドの情報の抜き
取りを防ぐことができる。また、通常POSTリクエストに対するレスポンスはキャ
ッシュに残らないため、hiddenフィールドの内容がキャッシュとして残ってしま
う可能性を下げることにも繋がる。処理1においてリクエスト1のメソッドを判別
し、GETの場合は処理を行わないようにする。または、再度POSTを用いてアクセス
しなおすようなレスポンスを返すようにしてもよいだろう。

　リクエスト1を受信後、サーバー側のプログラムは処理1を開始する。処理1にお
いて、もしまだセッションが開始されていなければ、セッションを開始する。
　トークンを生成する。トークンにはセッションIDなどと同様に充分な長さを持
つ予測不可能な文字列を使用する。
　トークンをセッションと結びつけた形でサーバー側で保存する。いわゆるセッ
ションオブジェクトに格納するのが分かりやすい方法だ。セッションオブジェク
トではなくデータベースを利用する場合には、トークンとセッションIDが1対1で
対応付けされた状態で格納する。
　hiddenフィールドにトークンを格納したレスポンス1をクライアントへ送信する。
この際、レスポンス1がキャッシュに残らないようにするため、適切なヘッダーフ
ィールドを付ける。
　処理1は以上となる。

　続いてクライアントはトークンを含んだリクエスト2を送信してくる。このリク
エストのメソッドはGETでもPOSTでもよい。
　リクエスト2を受信後、サーバー側プログラムは処理2を開始する。まず、送ら
れてきたトークンとセッションが正しい組み合わせであることを、処理1の際にサ
ーバー側に保存しておいた情報を用いて確認する。この組み合わせが正しくない
場合にはエラーとして扱い、処理をそこで終了する。組み合わせが正しい場合に
は次にすすむ。
　サーバー側で保存していたトークンの情報を破棄する。これによってトークン
が「ワンタイム」であることになる。

　以上でワンタイムトークンの処理が終了する。続いて「日記を書き込む」など
の、アプリケーション本来の機能を実行する。

　以上が正しい対策その1である。

　リクエスト1がGETでも安全に動作するようにしたい場合は、処理1においてトー
クンをhiddenフィールドには格納せず、Cookieに格納してクライアントに渡すよ
うにする。そしてレスポンス1を受信したブラウザがJavaScriptを使ってCookieか
らトークンを取り出し、hidden フィールドにその値を格納するようにする。具体
的には次のようなレスポンス1を返す。

-----
HTTP/1.0 200 OK
...（略）
Set-Cookie: token=8a23f9d44351895a48e15d26a8897eec;Path=/

<form action="..." method="...">
...（略）
<input type="hidden" name="token" value="" >
<input type="submit">
</form>

<script>
document.cookie.match(/token=(\w*)/);
var tokenInCookie = RegExp.$1;
document.forms[ 0 ].token.value = tokenInCookie;
</script>
-----

　また、トークンをワンタイムのものとするため、処理2においてCookieのトーク
ンをダミー値に置き換える。

　CSSXSS脆弱性はレスポンス1に含まれるクッキーの値を取得できないので、この
ようにすることでリクエスト1でGETを使用できることになる。

　英語で書かれたウェブサイトや文献ではCSRF対策の基本としてワンタイムトー
クン方式がまっさきに挙げられていることが多いが、CSSXSS脆弱性の存在までを
考慮したものは現時点（2006年3月）では見あたらなかった。


■0x08.) 正しい対策その2: パスワードの再入力を求める方法

　この方法はアプリケーションがユーザIDやパスワードを用いたいわゆる「ログ
イン」機能を持つ場合のみ使用できる。

　ワンタイムトークンを使用する場合と異なり、レスポンス1にはトークンのよう
な秘密情報が含まれない。そのため、この方法はCSSXSS脆弱性の影響を受けない。
また、レスポンス1がキャッシュに残っても問題が生じない。そのため、リクエス
ト1はGETでもPOSTでもよい。

　処理1は何も行わない。

　ユーザは画面1においてパスワードを入力する。そしてパスワードを含むリクエ
スト2が送信される。画面2の中のリンクなどからリファラーを通じてパスワード
が漏洩してはまずいので、このリクエスト2はPOSTでなければならない。

　処理2において、サーバー側プログラムは送信されてきたパスワードが正しいか
どうかをサーバー側のデータベースなどの情報を用いて照合する。パスワードが
間違っていればエラーとして扱い、処理を停止する。

　以上でパスワード再入力によるCSRF対策の処理が完了する。続いて「日記を書
き込む」などの、アプリケーション本来の機能を実行する。

　以上が正しい対策その2である。


■0x09.) 正しい対策その3: CAPTCHAを正しく使用する方法

　CAPTCHAはトークンの一種である。トークンがhiddenフィールドに格納された文
字列ではなく、画像データとしてクライアントへ送られるという点が上で説明し
たワンタイムトークン方式との違いだ。CAPTCHAは本来、HTTPクライアントを操作
しているのが人間なのか、あるいは自動化されたプログラムなのかを判別するた
めに使われる技術であり、CSRF対策とは無関係だ。ただ、CAPTCHAはトークンの一
種であるので、正しくワンタイムトークンとして使われれば、結果としてCSRF攻
撃を防ぐことができる。

　CAPTCHAを使用する方法はつまりはワンタイムトークン方式である。そのため、
上記で説明したhiddenフィールドを使ったワンタイムトークン方式に比べ、CSRF
対策としての利点はない。また、ユーザビリティや実装の複雑さで劣るため、進
んでCAPTCHA方式を採用する理由は存在しない。それがワンタイムトークンである
ことを知らずに「CSRF対策にはCAPTCHAを使おう。画像だから安全だ。」と考える
のは明らかに誤りなのである。

　それでもCAPTCHA方式を採用する場合には、それが正しくワンタイムトークンと
して動作するよう、次のように実装する必要がある。

　レスポンス1にはトークンのような秘密情報が含まれない。そのため、リクエス
ト1はGETでもPOSTでもよい。

　レスポンス1にはCAPTCHA画像へのリンクが含まれる。そのため、自動的にCAPT
CHA画像へのHTTPリクエストが発生する。このリクエストをリクエスト1.5とする。

　リクエスト1.5はPOSTでなければならない。理由はワンタイムトークン方式と同
様、CSSXSS対策と、キャッシュ対策を兼ねる。リクエスト1.5は仕組み上最初にG
ETで送られるので、再度POSTを用いてリクエストをしなおすような内容のレスポ
ンスを返す必要がある。

　CAPTCHA画像を含むレスポンス（レスポンス1.5とする）はキャッシュされない
よう適切なヘッダーフィールドを持つ必要がある。

　CAPTCHA画像に含まれるトークンはセッションと結びつけた形でサーバー側で保
存しておく。

　ワンタイムトークン方式と同様、リクエスト2はGETでもPOSTでもよい。

　処理2はワンタイムトークン方式と同じように行う。

　以上が正しい対策その3である。これはCSRF対策として正しく機能するが、先述
の理由により推奨しない。


■0x0A.) Basic認証の場合

　Basic認証を用いて「ログイン」機能を提供しているアプリケーションでも、必
要なCSRF対策は変わらない。Cookieを使ったセッション管理を行い、上で説明し
た対策のうちのひとつを正しく実装することでCSRF対策を行うことができる。


■0x0B.) リファラーについて

　リクエスト2のリファラーをチェックすることでCSRF対策が行えるのではないか、
とする説明が存在する。しかしこのリファラー方式は、正規ユーザのウェブブラ
ウザがきちんとリファラーを送ってくる場合のみ機能する。アンチウイルスソフ
トウェアやユーザ自身の意向によりリファラーを送出しない設定で使用されてい
るブラウザも多く存在するため、この方式は現実的には機能しないケースが多い。
利用者が限定されており、その全員にブラウザをリファラーを送るような設定で
使用するように求めることができるケースでは、リファラー方式はCSRF対策とし
て正しく機能する。

　リファラー方式を採用する場合には次のように実装する。

　処理2においてリクエスト2のリファラーを調べ、それが外部サイトのものであ
ればエラーとして処理する。また、リファラーが存在しない場合も同様にエラー
として処理する。

　また、リファラーを調べることにより、攻撃者がCSRF攻撃のために仕掛けた罠
ページを発見できる可能性がある。そのため、実際にCSRF攻撃が行われているの
かどうかを把握したい場合には、リクエスト2のリファラーを（外部サイトからの
ものに限り）記録しておくとよい。


■0x0C.) SSLについて

　SSLの使用はCSRF対策には基本的には関係がない。しかしHTTPSの通信はキャッ
シュされない、また盗聴されにくくなるなどの利点もあるため、可能な場合には
上記で挙げたCSRF対策と合わせて利用するのがよい。


■0x0D.) 採用すべきでないCSRF対策

　ここからは筆者がウェブサイトや書籍で見つけた、採用すべきでないCSRF対策
について説明する。これらの対策は意味がなかったり、かえってシステムを危険
な状態にしてしまうので、実施してはいけない。


■0x0E.) 採用すべきでない対策その1: セッションIDをトークンとして使う

　2006年3月の時点で、国内の多くのウェブサイトや書籍などで紹介されている方
法である。

　この方法は「ブラウザに脆弱性がない」ことを前提として考案されたものであ
る。しかし現実にはIEにCSSXSS脆弱性という「Cookieにはアクセスできないが、
hiddenフィールドの値にはアクセスできる」バグが存在している。そのためこの
方法を採用したウェブサイトは、リクエスト1でGETを使える場合、CSSXSS脆弱性
を悪用することによりセッションIDが盗まれ、結果としてセッションハイジャッ
クされてしまう可能性がでてくる。セッションハイジャックは明らかにCSRFより
も深刻なセキュリティ上の脅威である。つまりこの方法を採用することは、ウェ
ブサイトを（対策を行わない状態に比べて）危険な状態にさらしてしまうことに
なるのだ。CSRF対策をしたつもりが結果としてセッションハイジャック可能なセ
キュリティホールを作り込むことになってしまうという、なんともやりきれない
状態となる。そのため、この対策は採用してはならない。

　仮にウェブブラウザの脆弱性が存在しなければ、この方法はCSRF対策として機
能するかもしれない。しかしその場合でも、リファラからセッションIDが漏洩し
ないようにするため、リクエスト2は必ずPOSTである必要がある。この方式を紹介
しているウェブサイトや書籍ではこのことが明記されていない場合が多い。

　また、「わざわざ機密情報である（Cookieの）セッションIDをhiddenフィール
ドに格納する意味があるのか？　ハッシュ値などでよいのでは？」と思う感性は
エンジニアにとって大事だと考える。この方式においてセッションIDそのものが
トークンとして使用されているのは処理2においてセッションとトークンの結びつ
きを確認するのが簡単であるというだけの理由しか持たない。わずか数行のコー
ドを省略するために危険をおかす意味はない。

　この方式は日本語圏独自のものであり、英語圏ではこの方式をCSRF対策として
いる記述は見つからなかった。

　セッションIDそのものをトークンとして使うことには利点がないばかりか危険
（CSSXSS脆弱性で現実になったように、何かのきっかけでセッションハイジャッ
クに繋がるおそれがある）なので、この方式は採用してはならない。


■0x0F.) 採用すべきでない対策その2: 誤ったワンタイムトークン方式

　ワンタイムトークン方式では、トークンは必ずセッションと結びつけて扱う必
要がある。そうでない場合、攻撃者自らが画面1にアクセスして取得したトークン
を罠のページに埋め込む「トークン固定攻撃」が可能となってしまうためだ。そ
のため、このような実装をしてしまうとCSRF対策にならない。誤ったワンタイム
トークン方式とは、このような「セッションとトークンの結びつき」を持たない
方式を指す。


■0x10.) 採用すべきでない対策その3: リクエスト2をPOSTにする

　IMGタグなどを利用したCSRF攻撃の例を見ると、「ではリクエスト2がPOSTで送
られるようにすればよい」と考えてしまいがちだが、 JavaScriptを利用すること
で攻撃者は罠のページからPOSTリクエストを送らせることができるので、この方
法は対策にならない。具体的には次のようなコードが使われる。

-----
<form action="page2" method="POST">
...（略）
</form>

<script>
document.forms[ 0 ].submit();
</script>
-----


■0x11.) 採用すべきでない対策その4: 確認画面を挟む

　確認画面を挟む方法には2通りの実装が考えられる。ひとつは確認画面がhidde
n属性で全ての（確認画面に対してsubmitされた）フォームの値を持ち、3画面目
（実行画面、あるいは決定画面）にジャンプする際に再度それをsubmitするとい
うもの。もうひとつは確認画面を表示する時点でサーバー側のセッションオブジ
ェクトなどにフォームの値を保存しておき、3画面目を処理する際にそれを取り出
してデータベースなどを更新するものである。

　1つめの方法は罠のページから直接3画面目にCSRF攻撃を行うことで回避されて
しまうので、対策にはならない。

　2つめの方法は罠のページをフレームなどで分割し、それぞれに読み込まれる別
の罠のページから確認画面と3画面目へのCSRF攻撃を（必要があれば時間差をおい
て）それぞれ行うことで回避されてしまうので、これも対策にならない。

　それでは、元々の作りとして確認画面を含んだ3画面によって構成されるアプリ
ケーションでは、どのようにCSRF対策を行えばよいのだろうか。これは先述の通
り、ひとつの機能は2画面で構成されるという原則に沿って考えるとよい。1画面
目と2画面目（確認画面）によって「ユーザが入力した内容を表示する」というひ
とつの機能が実現されている。さらに2画面目と3画面目で「ユーザが入力した内
容をデータベースに登録する」のような別の機能が実現されている。つまり、こ
こではひとつではなく、2つの機能が連続して実行されているのだ。

　従って、CSRF対策の基本であるワンタイムトークン方式を、それぞれの機能に
ついて適用すればよい。

　まずひとつめの機能に対するCSRF対策として、1画面目でワンタイムトークンを
発行し、2画面目を表示する際の処理でこのトークンが正しいかどうか確認する。
これによって、ひとつめの機能に対するCSRF対策が実現する。そしてこの2画面目
を生成する処理の際にさらに異なるワンタイムトークンを発行し、 3画面目でこ
の2つめのトークンが正しく送られてくることを確認する。これによって2つめの
機能に対するCSRF対策が実現し、結果としてこの3画面によって実現される（ひと
つに見えるが実は2つからなる）機能全体のCSRF対策が実現されることになる。


■0x12.) 採用すべきでない対策その5: セッションIDを細かく変更する

　処理1でセッションIDを切り替え、このセッションIDを持たない場合には処理2
を行わないようにする、という方式である。「確認画面を挟む」方式と同様に、
罠のページをフレームなどで分割し、画面1と画面2に連続してCSRF攻撃を行うこ
とで回避されてしまうので、この方式は対策にならない。


■0x13.) CSRF用メーリングリスト

　筆者が本稿を書いた目的は、本当に正しいCSRF対策とは何なのかという疑問の
答えを得ることである。また、CSRFにまつわる情報の混乱を解決したいという思
いもある。現時点では本稿に記した対策方法が正しいものであると考えているが、
誤っている可能性ももちろんある。内容に誤りがあれば、その都度修正していき
たい。修正する場合、本稿は新しい文章として書き換えてしまい、古いものは古
いバージョンとして別名で保存し残していく形をとるつもりだ。

　本稿の内容についての意見や指摘などは大歓迎である。CSRFを中心にウェブア
プリケーションセキュリティについて話し合うための場所として、メーリングリ
ストを作成した。本稿に対するレスポンスがある場合にはこのメーリングリスト
を使用して頂ければありがたい。CSRFに関しては広くアンテナを張っているつも
りなので、ブログなどで言及してもらった場合にも反応するつもりだ。

Sea Surfers ML

MLへの参加はこちらから:
http://www.freeml.com/ctrl/html/JoinForm/seasurfers@freeml.com/

MLのトップページ
http://www.freeml.com/ctrl/html/MLInfoForm/seasurfers@freeml.com

　また、本稿で取り上げていない、ウェブサイトや書籍の中の細かい気になる点
についても、このメーリングリストの中で触れたいと考えている。


■0x14.) 関連リンク

おさかなラボ
http://kaede.to/~canada/doc/

PHPサイバーテロの技法（書籍）
http://www.amazon.co.jp/exec/obidos/ASIN/4883374718/

PEAK XOOPS Support&Experiment
http://www.peak.ne.jp/xoops/md/news/

俺専用mxxi :: ぼくはまちちゃん！
http://mxxi.hamachiya.com/

hoshikuzu | star_dust の書斎
http://d.hatena.ne.jp/hoshikuzu/

児童小銃 .456
http://d.hatena.ne.jp/rna/

INNOCENT CODE（書籍）
http://www.amazon.co.jp/exec/obidos/ASIN/0470857447/

2006年4月4日　Version 1.2
HTML版URL:
http://www.jumperz.net/texts/csrf.htm


