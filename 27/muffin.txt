x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: Intel x86命令の構造 ---

著者：muffin

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　MOVとかNOPとかの意味はわかった。それはCPUが理解できる数字に対応してるの
もわかった。でも実際の詳しい変換がわからない。「Intelのマニュアル（※1）
を読めといわれた」→「難しい」→「挫折」。
　Intelのマニュアルは非常に詳細に書いてるため簡単なことまで難しく感じてし
まいます。まったくの初心者が読むと発狂しそうです。とりあえず余計な知識を
抜いて骨格となるx86の命令の構造を知ることで、あまりにも詳しすぎるIntelの
マニュアルから必要なところだけ取捨選択ができるようになると思います。
　もちろんこれはIntelのマニュアルを読むためのマニュアルではありません。I
ntel x86の命令の基本構造はディスアセンブラの作成やらデバッガの作成やらコ
ードジェネレーターの作成やらポリモフィックエンジンの作成やらプロテクター
の作成やらに必須な知識なので、この辺に興味を持ってる方に読んでもらえれば
と思います。

【注釈】
（※1）http://www.intel.com/jp/developer/download/index.htm#ia32


■0x02.) Intel x86命令の基本的な構造

　基本的なx86命令の構造は次のようになっています。

+--------+--------+--------+-----+--------------+-----------+
| Prefix | Opcode | ModR/M | SIB | Displacement | Immediate |
+--------+--------+--------+-----+--------------+-----------+

●Prefix
　0〜4バイトのプリフィックス

●Opcode
　1バイトまたは2バイトのオペコード

●ModR/M
　1バイトまたはなし。

○ModR/Mの構造

7    6 5          3 2    0
+-----+------------+-----+
| Mod | Reg/opcode | R/M |
+-----+------------+-----+

●SIB
　1バイトまたはなし。

○SIBの構造

 7     6 5     3 2    0
+-------+-------+------+
| scale | index | base |
+-------+-------+------+

●Displacement
　1、2、4バイトのアドレスディスプレイスメントまたはなし。

●Immediate
　1、2、4バイトの即値またはなし


　では、ここからそれぞれの詳細な構造を順を追って解説していきます。


■0x03.) Prefix

●Prefixのタイプ

　5つのタイプのPrefixがあります。Prefixなし（0バイト）から最大4バイトまで
のPrefixが使用され、それにより命令の挙動が決定されます。

○Segment Prefix
　セグメントを決定するプリフィックスです。
　2E, 36, 3E, 26, 64, 65

○Operand Size Prefix
　オペランドのサイズを指定するプリフィックスです。ディフォルト以外のオペ
ランドサイズにするときに使用されます。
　66

○Address Size Prefix
　ディフォルト以外のアドレスサイズに変更するときに使用します。
　67

○REP/REPNE Prefix
　ループ命令で使用されるプリフィックスです。
　F3, F2

○Bus LOCK Prefix
　プロセッサのBUSを制御するプリフィックスです。
　F0

　一つのオペコードに対して複数のプリフィックスを利用できます。順番は特に
決まっていません。

●Segment Prefix

　DSが通常デフォルトのセグメントとなっています。これを変更するのがSegmen
t Prefixです。

2Eh : CS
36h : SS
3Eh : DS
26h : ES
64h : FS
65h : GS

---- ex ----
MOV EAX, DWORD DS:[EAX]   ;   8B00
MOV EAX, DWORD CS:[EAX]   ; 2E8B00
----

●Operand size Prefix

　オペランドサイズを変更します。Windowsの32ビット環境なら当然32ビットオペ
ランドがデフォルトで使用されることになりますが、オペランドサイズプリフィ
ックスを置くことによって16ビットのオペランドが使用できます。

---- ex ----
MOV EAX, EAX              ;   89C0
MOV EAX, EAX              ; 6689C0
----

●Address Size Prefix

　Operand size prefixと同様にデフォルトのアドレッシングのサイズを変更しま
す。

---- ex ----
MOV EAX, DWORD [EAX]     ;   8B00
MOV EAX, DWROD [BX+SI]   ; 678B00
-----

●REP/REPNE Prefix

　ストリング命令のループプリフィックスです。

---- ex ----
LODSD                         ;      AD
REP LODSD                     ;    F3AD
REPNE LODSD                   ;    F2AD
----

●Bus LOCK Prefix

　Busの制御をするプリフィックスです。


■0x03.) Opcode

●1バイトオペコード - パターン1

　簡単な1バイトオペコードにPUSHがあります。

PUSH REG --> 01010reg

　上のように変換されます。REGはレジスタの意味で、regは3ビットの値でどのレ
ジスタを使うかを指定しています。

PUSH EAX --> 50h --> 01010000

　つまり、regが000のときEAXを表しています。

7      3 2    0
+-------+-----+
| 01010 | 000 |
+-------+-----+
 opcode   reg

　最初の5ビットがオペコードPUSHを表し、後の3ビットがレジスタEAXを表し、ト
ータル1バイトで一つの命令を意味しています。

　3ビットで表すレジスタは次の表の通りになります。

+-----+--------+---------+---------+
| reg | 8 bits | 16 bits | 32 bits |
+=====+========+=========+=========+
| 000 |     AL |      AX |     EAX |
+-----+--------+---------+---------+
| 001 |     CL |      CX |     ECX |
+-----+--------+---------+---------+
| 010 |     DL |      DX |     EDX |
+-----+--------+---------+---------+
| 011 |     BL |      BX |     EBX |
+-----+--------+---------+---------+
| 100 |     AH |      SP |     ESP |
+-----+--------+---------+---------+
| 101 |     CH |      BP |     EBP |
+-----+--------+---------+---------+
| 110 |     DH |      SI |     ESI |
+-----+--------+---------+---------+
| 111 |     BH |      DI |     EDI |
+-----+--------+---------+---------+

　その他のreg指定をする1バイトオペコードに次のようなものがあります。

INC  REG        --> 01000reg
DEC  REG        --> 01001reg
PUSH REG        --> 01010reg
POP  REG        --> 01011reg
XCHG EAX, REG   --> 10010reg
MOV  REG, IMM32 --> 10111reg IMM32


----
MOV EAX,12345678h --> B8 78563412 --> 10111000 IMM32
                         ^^^^^^^^
                          IMM32 
----

　NOPという有名な1バイトオペコードがあります。他のオペコードのことは知ら
なくてもNOPが90hで表されることだけは知っているという方も多いかもしれませ
ん。上の表と下の2進数への変換を見比べてみてください。

90h --> 10010 000

　「XCHG EAX, REG」が「10010reg」、regは000なのでEAXとなります。つまり

90h --> 10010 000 --> XCHG EAX, EAX

　これがNOPの正体です。


●1バイトオペコード - パターン2

　次に別の型の1バイトオペコードを見てみます。

89C1h --> 10001001 11000001 --> MOV ECX, EAX

　2バイトになっていますが、C1h部分は ModR/Mフィールドというもので実際に命
令を表す部分は1バイトです。

　では、構造を見ていきます。

MOV ECX, EAX -->
             89h                  C1h
       10001001b            11000001b

+--------+---+---++-----+------+------+
| instr  | d | w || Mod | REG1 | REG2 |
+--------+---+---++-----+------+------+
| 100010 | 0 | 1 ||  11 |  000 |  001 |
+--------+---+---++-----+------+------+

instr  : オペコード命令を表す部分
    d  : d=0 のとき REG2 REG1の順
         d=1 のとき REG1 REG2の順
    w  : 32ビット環境において w=0 のとき  8ビットモード
                              w=1 のとき 32ビットモード
         16ビット環境において w=0 のとき  8ビットモード
                              w=1 のとき 16ビットモード
ModR/M : （2バイトオペコードのところで解説）

　次に例を示します。

---- dのビットが0のときと1のとき

+--------+---+---++-----+------+------+
| instr  | d | w || Mod | REG1 | REG2 |
+--------+---+---++-----+------+------+
| 100010 | 0 | 1 ||  11 |  000 |  001 |
+--------+---+---++-----+------+------+
 instr : 100010 = MOV命令
     d : 0 -> レジスタの順番がREG2 REG1
     w : 1 -> （32ビット環境で）32ビットモードを使用
   Mod : （今は無視）
  REG1 : 000 -> EAX, AX, ALのどれか
  REG2 : 001 -> ECX, CX, CLのどれか
-> MOV ECX, EAX

+--------+---+---++-----+------+------+
| instr  | d | w || Mod | REG1 | REG2 |
+--------+---+---++-----+------+------+
| 100010 | 1 | 1 ||  11 |  000 |  001 |
+--------+---+---++-----+------+------+
 instr : 100010 = MOV命令
     d : 1 -> レジスタの順番がREG1 REG2
     w : 1 -> （32ビット環境で）32ビットモードを使用
   Mod : （今は無視）
  REG1 : 000 -> EAX, AX, ALのどれか
  REG2 : 001 -> ECX, CX, CLのどれか
-> MOV EAX, ECX

----

　上の例ではdのビットを変化させることで命令の後にくるREG1とREG2の順が逆に
なることが分かったと思います。次にwビットの変化の例を見てみます。

---- wのビットが0のとき

+--------+---+---++-----+------+------+
| instr  | d | w || Mod | REG1 | REG2 |
+--------+---+---++-----+------+------+
| 100010 | 0 | 0 ||  11 |  000 |  001 |
+--------+---+---++-----+------+------+
 instr : 100010 = MOV命令
     d : 0 -> レジスタの順番がREG2 REG1
     w : 0 -> （32ビット環境で）8ビットモードを使用
   Mod : （今は無視）
  REG1 : 000 -> EAX, AX, ALのどれか
  REG2 : 001 -> ECX, CX, CLのどれか
-> MOV CL, AL

----

　dの特徴を考慮すれば、同じ命令でも2つの表現が作れるものがあることがわか
ります。

MOV EDI, EAX -> 8B F8 -> 100010 1 1  11 111 000
MOV EDI, EAX -> 89 C7 -> 100010 0 1  11 000 111

　次にこの型で使用される1バイトオペコードのリストを示します。

OR  REG, REG --> 000010dw
AND REG, REG --> 001000dw
SUB REG, REG --> 001010dw
XOR REG, REG --> 001100dw
CMP REG, REG --> 001110dw
ADD REG, REG --> 100000dw
MOV REG, REG --> 100010dw

●2バイトオペコード

　基本的なことは同じです。インテルのマニュアル参照。


■0x04.) ModR/M

　ModR/Mにより命令がどのような型のオペランドを使用するかを指定します。
　ModR/Mは以下のような構造になっています。

  7   6 5          3 2   0
 +-----+------------+-----+
 | Mod | Reg/Opcode | R/M |
 +-----+------------+-----+

●Mod

00 : メモリアドレス
     例) EAX, [EAX]
01 : 1バイトのディスプレイスメントを伴ったメモリアドレス
     例）[EAX+11]
10 : 1ダブルワードのディスプレイスメントを伴ったメモリアドレス
     例）[EAX+11111111]
11 : 両方のオペランドがレジスタ

●Reg/Opcode

　オペコードには1つのオペランドを必要とするものと2つのオペランドを必要と
するものがあります。1つのオペランドの命令ではReg/Opcodeの3ビットはコード
拡張としての役割をもち、2つのオペランドの命令ではレジスタを表すものとなり
ます。

　コード拡張の例を示します。次の例を見てください。

NOT EAX  --> F7 D0 --> 11110111 11 010 000
MUL EAX  --> F7 E0 --> 11110111 11 100 000
DIV EAX  --> F7 F0 --> 11110111 11 110 000

　Reg/Opcodeのところが異なるだけで3つの異なる命令を表しています。Reg/Opc
odeの部分が命令を決定している部分となっているわけです。

　次にレジスタを表している例を示します。

CMP EDX, EAX --> 39 D0

D0 --> 11 010 000
[
 Mod        :  11 --> 両オペランドがレジスタ
 Reg/Opcode : 010 --> EDX
 R/M        : 000 --> EAX
]

●R/M

　ここはModの部分によって意味が変わってきます。

Mod 00, R/M 101 : レジスタは使用されない。代わりにModR/Mの後のにDWORD値がきます。
                  例） XOR EAX, [12345678h] -> 3305 78563412
Mod 00, R/M 100 : SIBがModR/Mの直後に置かれることを意味しています。
Mod 01, R/M 100 : SIBがModR/Mの直後に置かれることを意味しています。
Mod 10, R/M 100 : SIBがModR/Mの直後に置かれることを意味しています。
Mod 11          : レジスタを表すことを意味しています。


■0x05.) SIB

　SIBはScale, Index, Baseの略です。SIBの構造を次に示します。

 7     6 5     3 2    0
+-------+-------+------+
| Scale | Index | Base |
+-------+-------+------+
  Scale * Index + Base

●Scale

00 : 2^0 = 1
01 : 2^1 = 2
10 : 2^2 = 4
11 : 2^3 = 8

●Index

Scaleで乗算するレジスタを指定します。

●Base

ベースレジスタを指定します。


---- 例：----
+-------+-------+------+-------------+
| Scale | Index | Base |             |
+-------+-------+------+-------------+
|    00 |   000 |  001 | [1*EAX+ECX] | = [EAX+ECX]
+-------+-------+------+-------------+
|    01 |   001 |  010 | [2*ECX+EDX] |
+-------+-------+------+-------------+
|    10 |   010 |  111 | [4*EDX+EBX] |
+-------+-------+------+-------------+
|    11 |   000 |  011 | [8*EAX+EBX] |
+-------+-------+------+-------------+
----


■0x06.) Displacement

　ModR/MでModが01または10のときディスプレイスメントを伴ったアドレス指定に
なります。

Mod 01 : 1バイトのディスプレイスメント
Mod 10 : 1ダブルワードのディスプレイスメント

---- 例 ----
8B BD 78563412 --> MOV EDI, [EBP+12345678h]

       instr : 100010 --> MOV r32, r/m32
           d : 1 --> REG1 REG2 の順
           w : 1 --> 32ビットモード
         Mod : 10 --> 1ダブルワードのディスプレイスメントを伴うメモリアドレス
  Reg/Opcode : 111 --> EDI
         R/M : 101 --> EBP
displacement : 12345678h *
-----

■0x07.) Immediate

　即値を表す領域です。
　例えば「05h」が「ADD EAX,imm32」を表すので、「05 78 56 34 12」で「ADD 
EAX,12345678h」となります。

■0x08.) あとがき

　これでIntelの基本的な命令のフォーマットが理解できたと思います。細かい命
令の詳細についてはIntelの命令レファレンスにすべて載っているのでそれを参考
にすればいいでしょう。
　これでディスアセンブラを作れるね！


