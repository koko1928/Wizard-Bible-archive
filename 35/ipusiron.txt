x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座 〜 第11回 〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　今までのWBではElGamal暗号（WB32）やRSA暗号（WB34）について解説しました。
こうした暗号における鍵生成アルゴリズム・暗号化アルゴリズム・復号アルゴリ
ズムなどでは、「乱数を選択」「modの計算」「巨大な数の累乗計算」などといっ
た暗号特有のアルゴリズムが行われていた。こうした暗号特有のアルゴリズムを
素朴に実装しようとすると効率が悪いことがある。場合によっては、暗号の安全
性さえも揺るがしてしまうことになってしまう。こうした問題に対して、効率の
よいアルゴリズムがすでに数学ライブラリに収録されていたりする。実際に暗号
を実装するときには、そうしたライブラリ内の関数を利用すればよいだろう。こ
こではアルゴリズムの動きをトレースすることによって、より数学的理解を深め
ることを目的とする。

　「暗号化・復号に必要な数学的作業」と「それに使われるアルゴリズム」の対
応表を次に示す。

---------------------------------------------------------------------
| 目的                                   | アルゴリズム             |
|----------------------------------------+--------------------------|
| a,bの最大公約数GCD(a,b)を求める        | ユークリッドの互除法     |
| ax+by=GCD(a,b)を満たす(a,b)を求める    | 拡張ユークリッドの互除法 |
| ay≡1 (mod n)を満たす乗法逆元yを求める | 今回解説予定             |
| 原始元の生成・判定                     | 次回解説予定             |
| 安全な乱数の生成                       | 擬似乱数生成器（PRG）    |
| べき乗計算                             | 今回解説予定             |
| 素数の生成・判定                       | Miller-Rabin法           |
| 連立合同方程式を解く                   | 中国人剰余定理（CRT）    |
| ハッシュ値の計算                       | ハッシュ関数             |
---------------------------------------------------------------------

　今回の記事では「乗法逆元を求めるアルゴリズム」と「べき乗計算のアルゴリ
ズム」について解説する。


■0x02.) 乗法逆元を求めるアルゴリズム

　乗法逆元を求める前に、いつも乗法逆元が存在するかどうかが心配である。こ
の心配事を解決するために、いくつか数学的事実を見ていく必要がある。

　まず、乗法逆元が存在する条件として、次の数学的事実がある。

[定理]35.1
「ay≡1 (mod N)を満たすyが存在する」⇔「GCD(N,a)=1」

　合同式や最大公約数について忘れてしまった方はきちんと復習しておいて欲し
いが、ここでは簡単に⇔の左右の意味について解説しておく。左辺は「ay-1がNの
倍数となるyが存在する」という意味である。即ち「ayをNで割った余りが1となる
ようなyが存在する」という意味である。一方、右辺は「Nとaの最大公約数は1」
という意味である。即ち「Nとaは互いに素」という意味である。
　次に「⇔」という記号（同値記号）の意味は、「左辺が成り立つならば、右辺
が成り立つ」かつ「右辺が成り立つならば、左辺が成り立つ」ということである。
　よって、定理の全体的な意味は「ayをNで割った余りが1となるようなyが存在す
るときは、Nとaが互いに素であるときに限る」ということになる。

　実際に数値例で確認してみる。N=10,a=7で考える。この2つは互いに素である。
このとき、7y≡1 (mod 10)を満たすyが存在するだろうか。ここでは、素朴に総当
りでyに値を入力してみる。

・y=1のとき、（左辺）＝7×1＝7≠1＝（右辺）
・y=2のとき、（左辺）＝7×2＝14≡4 (mod 10)≠1＝（右辺）
・y=3のとき、（左辺）＝7×3＝21≡1 (mod 10)＝（右辺）　←一致している！
・y=4のとき、（左辺）＝7×4＝28≡8 (mod 10)≠1＝（右辺）
・y=5のとき、（左辺）＝7×5＝35≡5 (mod 10)≠1＝（右辺）
・y=6のとき、（左辺）＝7×6＝42≡2 (mod 10)≠1＝（右辺）
・y=7のとき、（左辺）＝7×7＝49≡9 (mod 10)≠1＝（右辺）
・y=8のとき、（左辺）＝7×8＝56≡6 (mod 10)≠1＝（右辺）
・y=9のとき、（左辺）＝7×9＝14≡4 (mod 10)≠1＝（右辺）
・y=10のとき、（左辺）＝7×10＝70≡0 (mod 10)≠1＝（右辺）


　y=3のときに、左辺と右辺が一致することが確認できた。つまり、答えはy=3で
ある。

　この定理が一般的で成り立つことを証明しておく。アルゴリズムだけに興味の
ある方は証明は軽く読み流してもらって構わない。

[証明]
「GCD(N,a)=1」
⇔「∃x,y∈Z;Nx+ay=1」
⇔「ay≡1 (mod N)」　□

　[定理]35.1より、N=p（素数）のときには、ゼロを除くすべての要素に対して乗
法逆元が存在することがわかる。このことは、mod pの世界のいては、加算・減算
・乗算に加えて除算さえも自由に行えるということである。このように四則演算
が自由に行える世界を体と呼ぶ。
　この事実はとても重要である。そのため、暗号の世界では、しばしばmod pの世
界で考えることが多い。

　最後にきちんと定理としてまとめておこう。証明は明らかなので省略する。

[定理]35.2
pが素数とする。このとき、任意のa∈{1,…,p-1}に対して、乗法逆元a^(-1) mod
 pが存在する。

　以上の2つの定理より、mod pの世界を持ち出せば、最初の心配事は払拭するこ
とがわかる。それでは乗法逆元を求めるアルゴリズムを紹介する。アルゴリズム
なのでまず入出力を明確にしておく。

・入力：整数a,N（ただしN＞0）
・出力：整数a^(-1) mod N or「逆元は存在しない」というメッセージ

　アルゴリズムのコードは次の通りである（行列の形で書ければ見た目はすっき
りする）。floor(・)は引数を小数点切り捨てする関数とする。

-----
d0←a, x0←1
d1←N, x1←0
while(d1≠0){
	d0←d1, x0←x1
	d1←d0-floor(d0/d1)×d1, x1←x0-floor(d0/d1)×x1
}
if d0=1 then
	return a^(-1)=x0 mod N
else
	return 「逆元は存在しない」
-----


■0x03.) べき乗計算のアルゴリズム

　べき乗計算とは、「a,xが与えられたときにy=a^xを求める」計算である。累乗
に相当するxが大きければ大きいほど、必要な掛け算が膨大になってしまう。素朴
にやろうとすると（x-1）回の計算が必要である。例えば、3^5を素朴にべき乗計
算すると、3×3×3×3×3を計算する。×の個数が4回（＝5-1）なので、4回の掛
け算が必要ということである。暗号で使われている世界ではxが200桁ぐらいにな
ってしまうので、この素朴な計算では時間がかかりすぎる。

　計算量の説明をすると、x-1≒2^κが成り立つので、指数時間がかかってしまう。
これでは多項式時間の計算しかできないアルゴリズムでは歯が立たない。つまり
素朴な計算では効率が悪すぎるということである。

　そこで、y=a^x mod Nを効率よく計算する方法を考える必要がある。

　まず数値例から考えていく。3^20を計算したいとする。素朴な方法で計算する
と、19回の乗算をすることになる。ところが、3^20は次のように計算することも
できる。

((((3^2)^2)×3)^2)^2

　2乗しているところで乗算は1回（2^3は3×3だから）、「×」のところで乗算は
1回とカウントできるので、この計算ではたった5回で計算できてしまう。

　このような展開の計算と同様なことがアルゴリズムでも実現できる。アルゴリ
ズムで考えると初期段階などの処理が必要なので、5回ではなく7回の乗算が必要
となる。それでも素朴な方法による19回の乗算よりははるかに効率がよい。それ
ではアルゴリズムの基本的な考え方について解説する。

　まず、modの世界ではなく、普通にy=a^xを計算したいとする（a,xは正の整数）。
このとき次のように処理していく。

[Ⅰ]yに対して、y←1と初期値を代入する。
[Ⅱ]xの2進ビットパターンを上位ビットから1ビットずつ見ていき、各ビットに対
して次の処理を実行する。
　(2.1)まずyを2乗する。即ちy←y×y
　(2.2)そのビットが1ならば、さらにxを掛ける。即ちy←y×x

　この処理で、y=3^20を計算してみる（a=3,x=30）。

[Ⅰ]y=1
[Ⅱ]20の2進数は10100である。
　[1]一番左のビット1に対して、
　　(2.1)y=y×y=1×1=1　←（＝3^0）
　　(2.2)y=y×a=1×3=3　←（＝3^1）
　[2]左から2番目のビット0に対して、
　　(2.1)y=y×y=3×3=9　←（＝3^2）
　[3]左から3番目のビット1に対して、
　　(2.1)y=y×y=9×9=81　←（＝3^4）
　　(2.2)y=y×a=81×3=243　←（＝3^5）
　[4]左から4番目のビット0に対して、
　　(2.1)y=y×y=243×243=59,049　←（＝3^10）
　[5]左から5番目のビット0に対して、
　　(2.1)y=y×y=59,049×59,049=3,486,784,401　←（＝3^20）

　「×」は合計7回登場していることがわかる（括弧の数と対応）。例えば、2進
ビットパターンが最大5桁の場合は最悪でも10回の乗算で済むということがわかる。
なぜならば11111のときは、[Ⅱ]のすべての場合において2回の乗算を計算するか
らである。

　計算量での考察もしておく。y=a^xは素朴な計算の計算量はO(x)であるが、上記
の方法ではO(log(x))で済む。

　mod Nの世界で考えるときは、掛け算をする度にmod Nで考える。つまり、「y=
3^20 mod 13」を計算するときは次のようになる（a=3,x=30,N=13）。

[Ⅰ]y=1
[Ⅱ]20の2進数は10100である。
　[1]一番左のビット1に対して、
　　(2.1)y=y×y=1×1=1　←（＝3^0）
　　(2.2)y=y×a=1×3=3　←（＝3^1）
　[2]左から2番目のビット0に対して、
　　(2.1)y=y×y=3×3=9　←（＝3^2）
　[3]左から3番目のビット1に対して、
　　(2.1)y=y×y=9×9=81≡3 mod 13　←（＝3^4）
　　(2.2)y=y×a=3×3=9　←（＝3^5）
　[4]左から4番目のビット0に対して、
　　(2.1)y=y×y=9×9=81≡3 mod 13　←（＝3^10）
　[5]左から5番目のビット0に対して、
　　(2.1)y=y×y=3×3=9　←（＝3^20）

　さらに、使用変数を減らす方法を次に示す。x_(k-1)=1と仮定する。

[Ⅰ]まずy=aとおく。
[Ⅱ]次に、xの2進ビットパターン(x_(k-1),x_(k-2),…,x0)を上位ビットから1ビ
ットずつ見ていき、各ビットに対して次の処理を実行する。i=k-2から0まで次を
繰り返す。
　(2.1)y←y×y mod N
　(2.2)そのビットx_iが1ならば、さらにaを掛ける。即ちy←y×a mod N

　こうすることで使用する変数がyのみで済む。

　これで本題の乗法逆元を求めるアルゴリズムを紹介する準備ができた。アルゴ
リズムなのでまず入出力を明確にしておく。

・入力：整数a,x,N（ただしN＞0）
・出力：整数y=a^x mod N

　アルゴリズムのコードは次の通りである。

-----
x_(k-1)←1
y←a
i←k-2
while(i≧0){
	y←y×y mod N
	if(x_i==1)
		y←y×a mod N
	i=i-1
}
-----


■0x04.) 終わりに

　今回紹介したような（もっと効率がよいかもしれない）アルゴリズムは数論用
のライブラリであるNTL（http://www.shoup.net/ntl/）に収録されている。興味
のある方はNTLの関数を読んでみて欲しい。
　次回は引き続き暗号特有のアルゴリズムである「原始元の生成・判定のアルゴ
リズム」を紹介する予定である。原始元の生成は鍵生成アルゴリズムで度々必要
となる。原始元は興味深い性質をたくさん持っているので、そうした数学的事実
も一緒に紹介していければと思っている。

　では、また来月会いましょう。


