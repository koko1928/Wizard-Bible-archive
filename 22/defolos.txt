x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第6章: 割り込みプログラム [前編] ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　こんにちは、Defolosです。
　今回で10回目の参加となりました。10回目参加の記念（？）として2回にわたる
レポートを執筆したいと思います。
　今回は割り込みについて、少し技術的なレポートとなりましたが、私は割り込
みのプロでもプログラミングのスペシャリストでもありませんので、レポートの
内容の正確さは保障できません。もし誤った記述を見つけてくださいましたら、
報告頂けるとうれしく思います。

　今回割り込みについて執筆しようと思ったのは、最近Socketプログラミングを
勉強していて、非同期的に送受信を行う方法として割り込みを使ってはどうかと
考えたからです。ですので、このレポートは私が割り込みを勉強するために集め
たメモや資料をまとめたものです。


■0x02.) 割り込み

　コンピュータはプログラムの指示にしたがい、通常はプログラム通り順次的に
処理を行いますが、その処理の流れの中で各種の要因による事象がプログラムの
流れと独立して発生することがあります。これに応じて今処理しているプログラ
ムの流れを一時的に中断してほかの処理を実行することを割り込みといいます。
これはつまり、プログラム実行中に別の処理を割り込ませる仕組みということに
なります。
　また、割り込ませる処理のことを割り込みハンドラ（interrupt handler）とい
います。

　割り込みにはどういったものであれ、必ず優先レベル（priority level）がつ
けられています。これにより、同時に複数の割り込みが発生した場合に優先させ
るべき割り込みを優先して割り込ませることができます。例えば、キーボードイ
ベントなどの優先レベルが低い割り込みは、ハードウェアの障害発生通知割り込
みなどの優先レベルの高い割り込みの発生を優先しなければなりません。

　割り込みには発生要因別に外部割込みと内部割込みの二つに分けられます。

●外部割込み

　入出力装置や他の中央演算装置、コンピュータシステム外からの要因によって
引き起こされる割り込みのこと。主に電源異常、タイマー時間超過、入出力装置、
オペレータの介入、ハードウェアの誤りチェックなどで発生します。

●内部割込み

　プログラムに誤りが発生したときや、プログラム自身がなんらかの処理を実現
させるために制御の転移を必要としたときに発生します。つまり、プログラムの
進行に関連して引き起こされれる割り込みです。実行中のプログラムが0による除
算やオーバフロオーを引き起こしたとき、書込み禁止メモリへの書き込み処理な
ど、およびSVC（SuperVisor Call）命令（※1）の実行などで発生します。
　また、SVC命令のように、割り込みを起こす命令を実行することによって故意に
割り込みを起こさせることを、特に割り出し（Trap）とよびます。


（※1）プログラムがOSのカーネルに処理を依頼するための命令。この場合の「ス
ーパバイザ」と「カーネル」はほぼ同義である。
　一般的なOSでは、OSカーネル以外のプログラムが勝手にタスクを切り替えたり入
出力装置にアクセスすることは許されていない。そこで、一般のプログラムがカー
ネルの機能を利用する場合には、プログラムはSVCを利用してOSカーネルに処理を
依頼し、実際の処理はカーネルが特権を利用して行なっている。

IT用語辞典 e-Words（http://e-words.jp/）より引用


■0x03.) 割り込みの動作

　割り込みが発生すると、実行中のプログラムは実行が中断され、そのプログラ
ムの実行状態を表す制御情報をまとめたプログラム状態語（Program Status Wor
d：PSW）およびプログラム状態ベクタが一定の領域へ退避され、割り込み処理を
行うルーチンへ制御が移されます。割り込み処理を終えた後は退避させたプログ
ラム状態語を復帰させ、中断していた処理を続行します。

　ここでハードウェア割り込みの代表例、キーボードからの入力を例としてみて
いきたいと思います。ハードウェア割り込みとは外部割込みに含まれ、CPU外部か
らの影響によりCPUのINTRピンに対する状態の変化（HiからLowなど）があったと
きに、CPUが今まで行っていた処理を中断し、制御を特定のアドレスに移す機能で
す。
　キーボードなどのハードウェアは、通常オペレーティングシステムの起動時に
それぞれのハードウェアに対して個別のIRQ（Interrupt Request）を割り当て、
そのIRQ番号とハードウェアを関連付けて管理しています。もし、異なるハードウ
ェアが同一のIRQを利用するように設定してしまうと、多くの場合はオペレーティ
ングシステムはクラッシュしてしまいます。

●キーボードの処理手順

1：CPUがなんらかの処理を行っているとします。

2：そこへキーボードが押されると、キーボードと繋がっているPIC（Programabl
e Interrupt Controller）と呼ばれるチップがキーボードの入力を感知します。

3：PICはCPUのINTRピンに接続されていて、INTRピンの状態をONからOFFに変更し
ます。

4：PICはデータバスにキーボードに対応するIRQを流します。

5：CPUがINTRピンの状態変化を検出し、割り込み制御ロジックを動かします。

6：データバスのIRQを読み込み、それがキーボードであることを認知します。

7：CPUが（メモリの特定番地+IRQの数値）にある番地の内容のアドレスを取得し
ます。これはつまり、割り込み要求元（IRQ）と割り込む処理プログラムの先頭ア
ドレスとの対応表のような関係になっています。このような「割込み要求元」に
対する「割り込み処理プログラムの先頭アドレス」の対応表のことを割り込みベ
クタといいます。

8：実行しているプログラムの処理サイクル中で問題にならないタイミングで、ス
タックに現在実行しているプログラムの次の処理の番地を積みます。これはプロ
グラムの実行状態の退避にあたります。また、フラグレジスタの値も退避されま
す。

9：制御をIRQに対応する割り込みベクタのアドレスに移行させます。割り込みベ
クタのキーボード処理では、キーボードコントローラと通信し、どのキーから入
力があったのかという情報を取得しますが、一般的に割り込みベクタの処理は短
時間で済ませる必要があるため、多くの場合この処理ではどのキーからの入力か
という情報をFIFOバッファ（※2）に乗せるぐらいの処理しか行いません。

10：入力がどのプロセスに対して行われたものなのかを判別、割り振りをするの
はキーボードイベントに対する割り込みベクタの役割範囲外なので、多くの場合、
割り込みベクタはキー入力を適切にそれぞれのプロセスの入力バッファに分配す
る処理にまかせるようです。

11：CPUのIRET命令によって割り込みベクタの処理が終了します（Intelの場合）。
ステップ8でスタックに退避させた番地を取得し、制御を移行させます。これで割
り込み前の処理に制御が戻りました。

12：適切なタイミングでFIFOバッファから、その入力を受け取るべきプロセスの
キーボードバッファにキー入力が転送されます。

13：そこでプログラムがキーボードからの入力を読み込むシステムコール（read
など）を実行すると、このキーボードバッファからシステムコールの戻り値とし
てキーボードからの入力内容が得られます。

（※2）First-In First-Out方式。ある場所に格納したデータを、古く格納した順
に取り出すようにする方式。一番新しく格納されたデータが一番最後に取り出さ
れる。キュー(queue)と呼ばれるデータ構造はこの方式でデータを扱う。

IT用語辞典 e-Words（http://e-words.jp/）より引用


■0x04.) シグナル

　ハードウェア割り込みは非同期的に処理を行えるため、非常に有用な仕組みで
した。そこで、こういったハードウェア割り込みのような仕組みをプログラム的
に実装しようという考えがオペレーティングシステム全般で採用されました。こ
れはイベントドリブンのプログラミングのアイディアともなっています。

　UNIXでは、このハードウェア割り込みのような仕組みをプログラム的に実装し
ようという考えに積極的に取り組みました。その結果、非同期的に起きる可能性
のあるイベントには「シグナル」という仕組みを作りました。シグナルとはその
名の通り、信号の意味で、非同期的にイベントの信号を受け取り、処理する仕組
みのことです。
　シグナルで非同期的に起こる可能性のあるイベントには次のようなものがあり
ます。

●SIGALRM

　アラームタイマーの時間が満たされた場合に発生します。デフォルトでは、こ
のシグナルが発生してもプログラムは無視します。

●SIGINT

　ユーザーからの強制終了シグナルです。Ctrl+Cを押した場合などに発生します。
デフォルトの設定では、このシグナルを受け取ったプログラムは終了します。

●SIGTSTP

　プロセスの一旦停止のためのシグナルです。Ctrl+Zが押された場合などに発生
します。

●SIGCONT

　一旦停止されたプロセスを再開させるためのシグナルです。

●SIGCHLD

　そのプロセスが作り出した子プロセスの一旦停止または終了した場合に発生し
ます。デフォルトでは、このシグナルを受け取ったプロセスはシグナルを無視し
ます。

●SIGFPE

　浮動小数点演算のエラーや0による除算などが行われたときに発生します。デフ
ォルトでは、このシグナルを受け取ったプログラムは終了します。

●SIGEGV

　メモリアクセス違反（セグメンテーションフォルト）が起きたときに発生しま
す。デフォルトでは、これを受け取ったプログラムは終了します。

　これらのイベントは、いつどのようなタイミングで発生するかわかりません。
それゆえに、非同期的にシグナルを受け取り、処理することが非常に重要になっ
てきます。シグナルを用いないでこれらのイベントの発生を検出するには、ある
一定時間ごとにCPUがイベントの発生があったかどうかを確認していく必要があり
ます。これは一般的にポーリングと呼ばれる仕組みですが、大変非効率です。

　シグナルにはそれぞれデフォルトの動作が決められていますが、これはあくま
でデフォルトでの動作であり、後からプログラマーが自由に動作を変更すること
ができます。もしデフォルトの動作に満足なら変更せずにそのまま使うこともで
きます。
　また、UNIXの開発者たちはシグナルによるプログラムの停止にいくつかの種類
を設定しました。次に停止の種類を挙げます。

●SIGINT

　Ctrl+Cでの終了です。

●SIGTERM

　「プログラムはすみやかに終了せよ」という勧告です。これは、子プロセスを
生成しているプログラムにおいて子プロセスも終了させることを想定しています。

●SIGQUIT

　デフォルトの動作として、終了が定義されています。

●SIGKILL

　即刻プログラムを終了します。また、プロセスで再定義することはできません。


■0x05.) 関数ポインタ

　関数ポインタはシグナルにおいてシグナルハンドラを指定する場合に使用しま
す。ポインタというのはC言語の学習で鬼門とされるところです。関数ポインタと
いうのもポインタで、通常のポインタと同じようにその関数の開始アドレスを保
持する変数のことです。まずはポインタのおさらいからはじめてみましょう。

●ポインタ

　ポインタとは変数のアドレスを格納する変数です。変数というのはコンパイル
されたときにメモリ上の番地の一画に、必要な長さ分確保されます。この番地を
格納するのがポインタです。例えば、変数int test = 30はメモリ上に次のように
確保されます。

番地  [メモリ]
1   +---------+
    |         |
2   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |   30    |←test
102 +---------+
    !         !

　この例ではメモリ101番地をtestと名づけ、その番地に30を格納しています。t
estと名づけることでわずらわしい番地の番号を指定しなくてもよくなったわけで
す。このように番地に別名をつけるのはアセンブラでラベルにあたるものだと思
います。
　この例で変数testというものは101番地であると定義されています。そこで、こ
のtestというラベルのついた番地を他の変数に格納する仕組みをポインタといい
ます。ポインタも変数の一種ですから、当然メモリの番地の一画に確保されてい
るわけですが、この番地は特別な番地に確保されます。

　ポインタの宣言、利用は次のように行います。

-----
int main (void){

    int test = 0;     /* 変数testの宣言 */
    int *pointer;     /* ポインタの宣言 */
    int temp = 0;     /* 103番地に確保されるものとする */

    pointer = &test;  /* testのアドレスを格納 */
    *pointer = 2600;     /* 解説は後述 */
    temp = *pointer + 1; /* 解説は後述 */

return 0;
}
-----

　変数の前に*をつけることでポインタだと宣言します。pointer = &test;でpoi
nterにtestのアドレスを格納します。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |   0     |←test
102 +---------+
    |         |
103 +---------+
    |   0     |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer（内容は変数testのアドレス）
    +---------+

　ポインタを使ったデータのアクセスには*をつけます。*pointerで、pointerに
格納されているアドレスの中身を表します。それ故に*pointer = 2600;で「poin
terに格納されているアドレスの中身を2600で上書きする」という命令になります。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |  2600   |←test
102 +---------+
    |         |
103 +---------+
    |   0     |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer (内容は変数testのアドレス)
    +---------+

　temp = *pointer + 1;は、pointerに格納されている値（ここではtestのアドレ
スである101）に1を足すという命令になります。それによってtempに格納される
値は102になります。

番地  [メモリ]
1   +---------+
    !         !

100 .         .
    |         |
101 +---------+
    |  2600   |←test
102 +---------+
    |         |
103 +---------+
    |   102   |←temp
    +---------+
    !         !

900 .         .
    |         |
901 +---------+
    |  101    |←pointer (内容は変数testのアドレス)
    +---------+

参考：初心者のためのポイント学習Ｃ言語
（http://www9.plala.or.jp/sgwr-t/）

●関数ポインタ

　関数ポインタも前述の通り、通常のポインタと概念自体は変わりありません。
関数も機械語に翻訳され、メモリにロードされる段階になれば、関数の開始位置
（エントリポイント）も変数と同様にメモリに読み込まれます。このエントリポ
イントのアドレスを格納するのが関数ポインタです。
　C言語では関数名というのは関数のエントリポイントのアドレスに対するラベル
のように処理されていますので、関数ポインタという考え方はごく自然なもので
す。

-----
#include <stdio.h>

int main(void){

    void test(char *);  /* プロトタイプ宣言 */

    void (*func_p)(char *) = test; /* 解説は後述 */
    func_p("It is a test.");

return 0;
}

/*--------------------*/
/*     関数test       */
/*--------------------*/

void test(char * a){

    printf("%s\n", a);

}
-----

　関数ポインタは「戻り値の型 (*ポインタ名) (引数のリスト);」のように宣言
します。この例ではvoid (*func_p)(char *);がそれにあたります。つまり、voi
d型の戻り値を持ち、char型を引数とする関数のエントリポイントを格納するfun
c_pを宣言しているということになります。
　その直後の= test;という部分でfunc_pに関数testのエントリポイントのアドレ
スを格納しています。後はfunc_pに対してchar型の引数を渡せばfunc_pに格納さ
れたアドレス元の、関数testに引数を渡して実行させることができます。

　ポインタ、関数ポインタは本来もっと奥が深いものなのですが、今回は割り込
みについてが主題ですので、このレポートでは最低限必要なところだけに留め、
他は愛割させていただきます。興味のある方は検索エンジンなどで調べてください。

参考：目指せプログラマー！（http://www5c.biglobe.ne.jp/~ecb/c/16_01.html）
参考：ロベールの部屋（http://www1.kcn.ne.jp/~robe/cpphtml/html03/cpp03009.html）参考：稚内北星学園大学 情報メディア学部 Ｃ言語 金山 典世（http://www.wakhok.ac.jp/~kanayama/C/02/node183.html）


■0x06.) SysVシグナルとBSDシグナル、POSIXシグナル

　シグナルは、その処理体系に三つの種類があります。SysVシグナル、BSDシグナ
ル、POSIXシグナルの三つです。SysVシグナルはUNIXに古くから実装されており、
広く普及しました。しかし、SysVシグナルは後述しますが、リエントラント問題
などの対処に不備があり、シグナルの使い方によっては重大なエラーを引き起こ
しかねない処理体系でした。

　このSysVシグナルの不備に疑問を持ったBSD（Berkeley Software Distributio
n）の開発者たちは、SysVシグナルの不備を埋めるべくBSDシグナルというシグナ
ル処理体系を作りました。このBSDシグナルは、システムコール処理中のシグナル
発生について、およびシグナルハンドラ処理中の同一シグナルの発生についての
問題を解決しています。
　しかし、残念ながらBSDシグナルを作ったためにおきる問題もあったようです。
BSDシグナルを作ったことでSysVシグナルとBSDシグナルの2つのシグナル処理体系
ができ、多くのUNIX上で動作させようとした場合、同じsignal関数を用いてもSy
sVの処理体系をとるのか、BSDの処理体系をとるのかで、ソースコードを書き換え
る必要がでてきてしまいました。BSDは後から開発されたため、SysVシグナルもち
ゃんと動くように設計されていたため、BSDはそこまで普及せず、SysVシグナルで
記述する方法が一般的だったようです。

　このような2つの処理体系が入り混じった状況を打開するため、POSIX（Portab
le Operating System Interface for UNIX）（※3）は2つのシグナル処理体系の
長所をあわせ持つ、新しいシグナルシステムコールを作りました。これをPOSIXシ
グナルといいます。POSIXシグナルはSysVシグナル、BSDシグナルの両方の動作を
実装できますが、そのセマンティックス（※４）は全く別のものを利用していま
す。
　結論としていえることは、もはやSysVシグナルもBSDシグナルも古いものであり、
POSIXシグナルを利用するのが無難です。また、後継のLinuxはPOSIXシグナルをあ
る程度忠実に実装しているようです。

（※3）IEEEによって定められた、UNIXベースのOSが備えるべき最低限の仕様のセ
ット。各社のUNIX互換OSにはそれぞれ独自の拡張や仕様の変更が施され、互換性
が失われてしまったため、各OS間で最低限の互換性を確保するために定義された。
アプリケーションソフトがOSの提供する機能を呼び出すための方法（システムイ
ンターフェース）などを定義している。アメリカ規格協会（ANSI）や国際標準化
機構（ISO）でも標準として採用され、アメリカ政府機関に納入するUNIXシステム
が守るべき必須条件となっている。

IT用語辞典 e-Words（http://e-words.jp/）より引用

（※4）データの意味のこと。データの形式や構造に対応する概念。あるものごと
に対してどのような動作をするかということであり、ここではシグナルの処理の
方法ということになります。


■0x07.) 参考文献

・『情報処理ハンドブック』（オーム社）　ISBN:4-274-07502-8
・『コンピュータソフトウェア辞典』（丸善株式会社）　ISBN:4-621-03448-0
・『杉浦康仁(三木淑生)のホームページ』杉浦康仁 著
http://www.nurs.or.jp/~sug/index.shtml


■0x08.) さいごに

　今回は前半ということで、技術的なところにはあまり触れず、歴史や概要とい
った部分を主体にレポートしました。次回はプログラム的な視点でレポートを行
っていきたいと思います。今回のレポートで不備のある点、誤った点などは指摘
していただければ幸いです。

　それではまた来週にお会いしましょう。

