x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座 〜 第6回 〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回まではブロック暗号の利用モードやFeistal構造などについて解説しました。
今回は共通鍵暗号系の認証について解説します。


■0x02.) MACとは

　MAC（Message Authentication Code）とはメッセージを認証するための仕組み
です。敵によるなりすましやメッセージの改ざんを防止することが目的です。メ
ッセージ認証は暗号化よりも重要ともいえます。暗号化が必要ない場合であって
も、そのメッセージが信頼できるものであることは常に確かめることができなけ
ればならないからです。

　次回以降で登場する公開鍵暗号系の場合はデジタル署名という仕組みがありま
すが、共通鍵暗号系ではそれに対応したセキュリティ機能をMACで実現します。た
だしデジタル署名の場合は正真性・認証・否認性をチェックできますが、MACの場
合は正真性・認証しかできません。


■0x03.) MACの仕組み

　MACは2つのアルゴリズムである、鍵生成アルゴリズムGと認証子生成アルゴリズ
ムSで表されます（図1、図2参照）。

（図1）http://security2600.sakura.ne.jp/main2/image1/MAC2.jpg
（図2）http://security2600.sakura.ne.jp/main2/image1/MAC3.jpg

　次にMACの仕組みを示します（図3参照）。

1：送信者と受信者はGで生成された秘密鍵Kを共有しておきます。ここでのセキュ
リティパラメータkとはビット長を意味します。
　ここは秘密鍵暗号系での暗号化のときと同様に一番最初に必要な準備です。秘
密鍵暗号系の安全性はこの鍵配送に強く依存していますが、MACの場合でも同様で
す。

2：次に送信者はKを利用して、メッセージMに対する認証子（MAC値）Tagを生成し
て、ペア(M,Tag)を受信者に送ります。

3：受信者は(M,Tag)を受け取ったら、Kを利用して(M,Tag)の正当性をチェックし
ます。

（図3）http://security2600.sakura.ne.jp/main2/image1/MAC1.jpg


■0x04.) MACの安全性

　受信者がacceptしてしまうような(M,Tag)を敵が生成してしまうことを偽造と呼
びます。一般に鍵Kを求めるよりも、偽造するほうが容易です。

　暗号設計者はKを求められないことは当然だが、偽造すら不可能であるようなM
ACを構成する必要があります。鍵Kを知らずに検証式を満たすような(M,Tag)を作
れないとき、MACは安全であるといいます。

　敵の最も単純な攻撃方法は、送信者が送信した(M,Tag)を何も見ずに偽造を試み
ることです。そして最も強力な敵の攻撃方法は、選択メッセージ攻撃があります。
選択メッセージ攻撃とは何らかの方法で複数のメッセージと認証子の組を入手し、
その情報を偽造することです。選択メッセージ攻撃のモデルは、メッセージM1,…
,M_qを自由に選んで、それに対応する認証子を入手できる状況において偽造を試
みると考えることができます（図4参照）。このとき敵がM/∈{M1,…,M_q}である
ような(M,Tag)を偽造できたとき、敵は偽造に成功したことになります。

（図4）http://security2600.sakura.ne.jp/main2/image1/MAC4.jpg

[定義]~
敵が偽造できる確率が無視できる程度に小さいとき、そのMAC方式は選択メッセー
ジ攻撃に対して安全であるという。


■0x05.) 各種MAC

　MACはブロック暗号を利用して実現できます。WB28/29でも解説しましたが、ブ
ロック暗号には様々な利用モードがありました。その中でも安全であったのはCB
CモードとCTRモードであり、MACではCBCを用いた方式が使われています。また他
にはいくつか種類があります。

・CBC-MAC（Cipher Block Chaining-MAC）
・EMAC（Encrypted MAC）
・OMAC（One key MAC）
・UMAC（Universal-hash MAC）
・HMAC（Hash MAC）

　本講座ではCBC-MAC・EMAC・OMACだけに絞って解説します。


■0x06.) CBC-MAC方式

　CBC-MAC方式はブロック暗号の利用モードのひとつであるCBCモードを利用して
実現した方式です。

　メッセージをM=(m1,m2,…,m_t)として、各iにおいて|m_i|=n（m_iはnビット長
であることを意味する）であるとします。このときCBC-MAC方式は次のように記述
されます。
　鍵はブロック暗号の鍵Kとして、認証子生成アルゴリズムは次のように計算しま
す。

c1=E_K(m1)
c2=E_K(c1+m2)
…
c_t=E_k(c_(t-1)+m_t)

　最後に認証子をTag=c_tとします。図にすると次のようになります（図5参照）。

（図5）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC.jpg


●CBC-MAC方式の安全性

　各メッセージの長さtが一定の場合、CBC-MAC方式は選択メッセージ攻撃に対し
て安全であることが証明されています。しかし異なる長さのメッセージを許すと
き、即ち可変長の場合は簡単に偽造されてしまう。その偽造例を次に示す。

　まず敵はnビット長のmに対する認証子Tagを入手したとします。
　次にM'=(m,m+Tag)すれば、(M',Tag)というメッセージと認証子のペアでCBC-MA
Cの検証式を通過して受信者にacceptさせてしまうことができます。
　よって敵は偽造に成功したことになります。


●練習問題

　CBC-MAC方式について次の設問に答えよ。

（1）m∈{0,1}^nに対する認証子がTagであったとする。このときM'=(m,m+Tag)に
対する認証子もTagであることを示せ。

　まずCBC-MACの構造を思い出しましょう。
　アタッカーがMにm+Tagを付加します。すると受信者は次のように計算するはず
です（図6参照）。

（図6）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC2.jpg

　Tag'がTagと一致すれば受信者はacceptします。よってTag'=Tagを導くことが目
標となります。

Tag'
=c2
=E_K(c1+m+Tag)
=E_K(E_K(m) + m + Tag)　（∵c1=E_K(m)）
=E_K(Tag + m + Tag)　（∵仮定より、E_K(m)=Tag）
=E_K(m)
=Tag

（2）M=(m1,m2)に対する認証子がTagであったとする。ただしm1,m2∈{0,1}^nであ
る。この情報を利用して偽造せよ。

　CBC-MACの構造に仮定を満たすように書き下していきます（図7参照）。

（図7）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC3.jpg

　すると次の関係式が成り立ちます。

・c1=E_K(m)
・Tag=c2=E_K(c1+m2)=E_K(E_K(m1))

　このとき敵はM'=(m1,m2,m1+Tag,m2)を偽造すればうまくいきます。これは（1）
の結果から推測するわけですが、（2）ではm1とm2の2つあるから少し複雑になっ
ています。これが本当に偽造に成功しているかを示す。

　M'に対してCBC-MACの仕組みを適用させます（図8参照）。

（図8）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC4.jpg

　すると次が成り立ち、最終的にTag'=Tagが示すことができればOKです。

c1'
=E_K(m1)
=c1

c2'
=E_K(c1' + m2)
=E_K(c1 + m2)
=Tag

c3'
=E_K(c2' + m1 + Tag)
=E_K(Tag + m1 + Tag)
=E_K(m1)
=c1

Tag'
=c4'
=E_K(c3' + m2)
=E_K(c1 + m2)
=Tag

（3）ブロック暗号がランダム置換族である場合を考える。M=(m1,m2)に対する認
証子をTag、M'=(m1',m2')に対する認証子をTag'としたとき、Tag=Tag'となる確率
を求めよ。MとM'の関係について場合分けして考えよ。

　M,M'それぞれにおいて、2番目の暗号化アルゴリズムE_Kへの入力は次のように
なります。

x=m2 + E_K(m1)、x'=m2' + E_K(m1')

　よってTag=Tag'となる必要十分条件は次が成り立つときです。

m2 + E_K(m1)=m2' + E_K(m1')
E_K(m1) + E_K(m1')=m2 + m2'　←(*)

　「E_K(□) + E_K(□)=○ + ○」と見ると、左辺の2つの□は(m1,m1')というペ
アの入力、右辺の2つの○は出力を考えることができます。そこで次のように4つ
に場合分けします。

|-----------------------|
|           |   入力    |
|           |-----------|
|           | ＝  | ≠  |
|-----------+-----+-----|
| 出力 | ＝ | [4] | [1] |
|      |----+-----+-----|
|      | ≠ | [2] | [3] |
|-----------------------|

[1]m1≠m1'かつm2=m2'のとき

　(*)はE_K(m1) + E_K(m1')=0^nとなる。このときm1≠m1'は起こりえない。よっ
てPr[Tag=Tag']=0

[2]m1=m1'かつm2≠m2'のとき

　このとき必ずTag≠Tag'となる。よってPr[Tag=Tag']=0

[3]m1≠m1'かつm2≠m2'のとき

　次図のように考えて、(*)を満たすパターンの総数を求めます（図9参照）。こ
ういう考え方は以前のWBでもやっているので、置換や関数の総数計算が理解でき
ない場合は戻って確認してみてください。ポイントは(*)という式に縛られてる状
態での総数ということです。

（図9）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC5.jpg

Pr[Tag=Tag']
=Pr[E_K(m1) + E_K(m1')=m2 + m2']
={(2^n)×1×(2^n-2)!}/(2^n)!
=1/(2^n-1)

[4]m1=m1'かつm2=m2'のとき

Pr[Tag=Tag']
={2^n×(2^n-1)!}/(2^n)!
=(2^n)!/(2^n)!
=1

　普通に代入してもわかるように(*)は0^n=0^nとなりいつでも成り立つ。

（4）M=(m1,m2)に対する認証子をTag、M'=(m1',m2')に対する認証子をTag'とした
とき、Tag=Tag'となる確率が1/2であった。このとき{E_K}は擬似ランダム置換族
でないことを証明せよ。

　{0,1}^n上の置換πをオラクルとする識別アルゴリズムDを次のように構成しま
す。
　DはまずπをCBC-MAC方式の暗号アルゴリズムとして利用して、Mに対する認証子
Tag、M'に対する認証子Tag'を求めます。このときTag=Tag'ならD^π=1、Tag≠Ta
g'ならD^π=0とします（図10参照）。

（図10）http://security2600.sakura.ne.jp/main2/image1/CBC-MAC6.jpg

　このときπが{E_K}からランダムに選ばれていると仮定すると、次のようになり
ます。

P_random=Pr[Tag=Tag']=1/2

　一方πがランダム置換族P_nからランダムに選ばれているときは、(3)の結果よ
り次のようになります。

P_A=Pr[Tag=Tag']=1/(2^n-1)

　よってDのアドバンテージは次のようになります。

Adv(D)
=|P_random - P_A|
=|1/2 - 1/(2^n-1)|
≒1/2

　これは十分大きいです。ゆえに{E_K}は擬似ランダム置換族ではないことがわか
ります。



■0x07.) EMAC方式

　EMAC方式は可変長のメッセージに対しても安全なMAC方式です。ブロック暗号の
鍵が2つ必要という特徴を持つ。

　EMAC方式はCBC-MAC方式における認証子を新しい鍵K2で暗号化して認証子Tagを
生成します。

Tag=E_K2(CBC_K1(M))

　図にすると次のようになります（図11参照）。

（図11）http://security2600.sakura.ne.jp/main2/image1/EMAC.jpg


●EMAC方式の安全性

　各メッセージの長さがブロック長nの整数倍であると仮定します。このときEMA
C方式は選択メッセージ攻撃に対して安全であることが証明されています。


■0x07.) OMAC方式

　OMAC方式はブロック暗号の鍵がひとつで済み、メッセージ長がブロック長nの整
数倍である必要がないという特徴を持つMAC方式です。

　鍵はブロック暗号の鍵Kとして、認証子生成アルゴリズムはまず次のように計算
します。

L=E_K(0^n)

　次にメッセージM=(m1,m2,…,m_t)に対して次のように計算します。

c1=E_K(m1)
c2=E_K(c1+m2)
…
c_t-1=E_K(c_(t-2)+m_(t-1))

　最後に認証子を次のように求めます。

[1]|m_t|=nの場合は、Tag=E_K1(c_(t-1)+m_t+L・u))
[2]|m_t|＜nの場合は、Tag==E_K1(c_(t-1)+(m_t||1||0^i)+(L・u^2))

　ここでiは|m_t||1||0^i|=nとなるように選びます（||は連結を意味する）。ま
たuは拡大体GF(2^n)上の特定の要素であり、「・」はGF(2^n)上の乗算を表す。
L・u^2は L・u^(-1)に置き換えても、安全性・効率はほぼ同じになります。

　図にすると次のようになります（図12参照）。

（図12）http://security2600.sakura.ne.jp/main2/image1/OMAC.jpg

　これを理解するには次回の拡大体の理解が必要なので、今回はOMAC方式とい
ものがあるんだと頭の片隅に記憶しておく程度で十分です。


●OMAC方式の安全性

　OMAC方式は任意の可変長のメッセージにおいて、選択メッセージ攻撃に対して
安全であることが証明されています。


■0x08.) おわりに

　今回でやっと秘密鍵暗号系（＋α）の話は終わりです。正直長かったですね…。
仕様を読んだだけでは「ふーん」という程度の理解で終わってしまいます。仕様
に実際に数値を入れて遊んでみたり（平文から暗号文を作って、暗号文から正し
い平文にきちんと復号されることを確かめる）、敵の立場になってあらゆる攻撃
を想定してみたりしてみてください。また問題を解くことも重要ですが、自分で
問題を作ることも勉強になります。そうすることで理解をさらに深めることがで
きるはずです。

　次回は公開鍵暗号系に入る前に必要な基本的な数学について解説します。実は
今回までの話を理解していなくても、次回以降からゼロの状態から理解すること
も可能なので、これまでに内容を追えなくなってしまったという人でもフレッシ
ュな気持ちでチャレンジしてみてください。

