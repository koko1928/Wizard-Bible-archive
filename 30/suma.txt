x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: Rapid Development of Packer Vol.2 ---

著者：suma

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　お久しぶりです。最近私は「パッカー」「パッカーを作ることの意義」につい
て考えています。パッカーを使用する目的をあげることはできますが、パッカー
によって解決できる範囲は広いのか、また逆にパッカーによってもたらされる被
害は存在するのか、するならどれくらい簡単に解決できるのか…と、頭の中でく
るくる言葉が回っています。今回はVol.1でできなかったソースコードやプログラ
ミングテクニックの解説の後に、ローダーのデバッグテクニックについて考察し
ていきたいと思います。


■0x02.) パッカー開発テクニック

　パッカーを開発する方法について再確認してみましょう。パッカーを開発する
には対象となる実行ファイルをパックする「パッカー本体」と、元のプログラム
をメモリ上に展開（アンパック）する「ローダー」の2つのプログラムを作成する
必要がありました。

　前回のプログラムに機能追加・修正を施しているので、次のファイルをダウン
ロードしてください。

http://beautiful.homelinux.net/~sky-software/wb/rdp2/pack_20061216.zip


■0x03.) Visual Studio ソルーション「pack.sln」

　Visual Studioのソルーションは、複数または単数のプロジェクトをグループ化
するものです。pack.slnを開いてください。pack.sln内のプロジェクトについて
説明します。

・pack：パッカー本体
・PackLib：実行ファイルのPEフォーマット読み込み用ライブラリ
・TestLoader：ローダーのテストコード（デバッグテクニックの項で説明します）
・zlib：圧縮ライブラリzlib（http://www.zlib.net/）
・ZLoader：ローダー

　パッカーとローダーはそれぞれ単一のプロジェクトとしてソルーションに格納
されています。パッカーとローダーの依存関係について見ていきましょう。パッ
カー（packer.exe）は実行時にローダー（ZLoader.exe）を読み込み、対象の実行
ファイルにローダーを付加します。ここで、Zloader.exeが存在しない状態でpac
k.exeを実行しても、当然パックに失敗します。ローダーが存在しなければパック
は不可能であるわけです。そのため、pack.exeより先にZLoader.exeが生成されて
いる必要があります。このような場合に役立つのがソルーションです。「ソルー
ションを右クリック→プロパティ→プロジェクト依存関係」より、プロジェクト
の依存関係を設定できます。これで必要なプロジェクトは自動的に先にビルドさ
れるようになります。


■0x04.) Visual Studio 2005への対応

　公開したパッカーはVisual Studio .NET 2003を使用して作成しています。これ
をVisual Studio 2005でビルドすると、ZLoaderでリンクエラーが発生します。こ
のエラーは、C標準ライブラリのmemsetとmemcpyのふたつの関数がリンク時に見つ
からないことが原因となっています。このパッカーは都合上、ローダーにC標準ラ
イブラリをリンクしない設定をプロジェクトオプションでしています（※1）。そ
れに加えて、関数のインライン展開を有効にしていますが、Visual Studio 2005
ではmemcpy・memsetがインライン展開されないことが理由でリンクエラーが発生
してしまいました。

　memcpy・memsetのふたつの関数がリンク時に見つからないだけなので、なんと
かしてこれらの関数をローダーにリンクすれば解決します。C言語から呼び出し可
能な（呼び出し規約が__cdeclである）関数の自作を考えますか？　Visual Stud
ioにはC標準ランタイムのソースコードが付属しています。Visual Studio 2005を
インストールしたフォルダの階層下の「VC\crt\src」からmemcpy.cとmemset.cを
コピーし、プロジェクトZLoaderに追加してください。

（※1）C標準ライブラリ内でWin32API関数を呼び出すため、C標準ライブラリをリンクしたプログラムはDLLをインポートする必要があります。このパッカーでは、ローダーにDLLのインポートをさせない手段をとったため、C標準ライブラリをリンクできないという制約がついてしまいました。


■0x05.) ローダーの作り方（コーディング）とバリエーション

　ローダーの作成には、ひとつのプロジェクト（実行ファイル）として作り、再
配置セクションを利用する手段を取りましたが、別の方法によるローダーの作成
も可能です。というよりむしろ、私が知っているオープンソースのパッカー（※）
は別の方法を取っています。次の記事の「Make Extra Section」の項にあるコー
ドを読んでください。

・Make your owner PE Protector Part 1: Your first EXE Protector
http://www.programmersheaven.com/2/PE-Protector#make

　ここではローダーを関数内にインラインアセンブラで記述し、ローダーの終端
部分にアルファベットで表すことができる命令で、終端識別用の文字列を埋め込
んでいます。そして関数のアドレスから終端識別用の文字列を検索し、ローダー
のサイズを計算します。MASMによるローダーの作成の場合は、OFFSET演算子によ
ってラベルのオフセットが簡単に求められるため、終端識別用の命令を埋め込む
代わりに、開始と終わりにラベルを使用することもできます。

（※）オープンソースのパッカー
・UPX: the Ultimate Packer for eXecutables
http://upx.sourceforge.net/

・Yoda's Crypter（MASM）
http://scifi.pages.at/yoda9k/

・Yoda's Protector（Viaul Studio .NET 2003）
http://yodap.sourceforge.net/

・Packman
http://packman.cjb.net/（Visual Studio 2005）

・Morphine v2.7（Delphi/Visual Studio .NET 2003）
　アンチウィルス検出回避を目的としたポリモフィックエンジン内臓のプロテクター
http://hxdef.org/


■0x06.)  ローダーのデバッグテクニック

　パッカーとローダーが正しく動作するか確かめるにはどうすればよいでしょう
か。どちらも正常であればパッカーを使用しても、元の実行ファイルは正しく動
作するはずです。しかし正しく実行できなかった場合はどちらに問題があるので
しょうか。片方だけに、もしくは両方ともに問題があるのかもしれません。ひょ
っとするとどちらにも問題がなく、対象の実行ファイルだけに問題がある可能性
もあります…。今はパッカーの動作を確かめることについてですから、対象の実
行ファイルは除外することにしますが、パッカー本体とローダーの両方が正常に
動作してこそ、パッカーは役割を果たすことができます。

　パッカーとローダーのデバッグ・テスト方法について考えてみましょう。圧縮
・展開ような処理、単体機能をライブラリを作成する場合などには単体でテスト
すればよいでしょう。しかしパッカーとローダーの場合、両方が協調して動作す
るため、バグがあることがわかっていても、どちらにバグがあるか調べることは
簡単ではありません。

　パッカーに実装する機能にもよりますが、ローダーを作成していく順番として
粒度がより小さいものから大きいものへ、テストがより簡単な物から難しいもの
へ、そしてできる限り機能単体をテストできる仕組みを作っていくのがよいと考
えられます。具体的な例を次に示します。

・実行ファイルに付加されたローダーが実行できるか

・パッカーからローダーへデータ（アドレス・圧縮したデータなど）を正しく受
け渡すことができるか

・パッカーが「圧縮」したコードがローダーで「展開」され、元のプログラムが
正しく動作するか


■0x07.) 対象実行ファイルなしでローダーをテストする

　ローダーをテストしようとすると、実行ファイルにローダーを付加してからロ
ーダーの動作を確認することになります。そして、ローダーが付加された実行フ
ァイルをデバッグするには、デバッガで地道にトレースするしかありません。ロ
ーダーをデバッガでデバッグする作業は大変骨の折れる作業です。開発を敏速に
行うには、もっと簡単にデバッグできる必要があります。ローダー専用のデバッ
ガを作ることも考えられます。しかしよいアイディアがある場合は別として、デ
バッガ作成にかかるコスト（時間・手間）を考えると本末転倒でしょう。

　別の方法として対象実行ファイルにローダーを付加するのではなく、テスト用
のプログラム上でローダーを実行させる方法を提案します。ローダーの処理を思
い出してください。圧縮されたコードをメモリ上に展開し、展開されたコードに
実行を移るだけです。

　前回のパッカーに適用させる形で、実際にテストプログラムを作成しました。
今回配布のプロジェクトTestLoaderがそれにあたります。主要なポイントを次に
示します。

・ローダー・圧縮されたコードはヒープ上におかれる

・ローダーのコードを実行する直前、スタックにKernel32.dll内のアドレスをpu
shする

・構造化例外（SEH）を設定によって、ローダーの例外を検出可能


■0x08.) おわりに

　今回はローダーの作り方・デバッグ方法のふたつに焦点をあててみました。今
回紹介したデバッグテクニックのいくつかは「デバッグ論」にとどまっており、
効果を試すことができませんでした。次回はこれらにのっとった実装をしたり、
パッカーへの機能追加および、「Rapid Development」という名にふさわしい開発
方法の考察ができればいいなと思っています。
　前回PEヘッダーの説明のあるサイト・書籍をほとんど紹介できなかったので、
最後にいくつかあげてみたいと思います。

●Windows実行ファイル「EXE」の謎に迫る

　CodeZineに掲載されているActiveBasic作者である山本大祐氏の記事です。

・Windows実行ファイルのバイナリ概要
http://codezine.jp/a/article/aid/403.aspx

・EXEファイルの内部構造（PEヘッダ）
http://codezine.jp/a/article/aid/412.aspx

・EXEファイルの内部構造（セクション）
http://codezine.jp/a/article/aid/413.aspx

●Asm Tut Lite

　「チュートリアル」→「Advanced」よりアンパック・PEヘッダーに関するチュ
ートリアルを読むことができます。

http://rain.prohosting.com/lwtemp/

●MSDN Magazine

・An In-Depth Look into the Win32 Portable Executable File Format
http://msdn.microsoft.com/msdnmag/issues/02/02/PE/

・An In-Depth Look into the Win32 Portable Executable File Format, Part 2
http://msdn.microsoft.com/msdnmag/issues/02/03/PE2/

●書籍「クラッキング・バイブル」

『2.6◆PEファイルフォーマット（TEXT◎DokoDon）』, p.293-332

