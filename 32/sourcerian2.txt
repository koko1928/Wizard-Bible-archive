x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: バイナリプロテクション2　〜アプリケーションデバッギングの防止〜 ---

著者：sourcerian

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　デバッガには大別してカーネルデバッガとアプリケーションデバッガがありま
す。SoftIceやWinDBGなどはカーネルデバッガ、W32DasmやOllyDbgなどはアプリケ
ーションデバッガに分類されます。今回はそのアプリケーションデバッガによる
デバッギングを防ぐというお話です。退出

　本題に入る前に用語の説明をしないと頭が混乱しそうです。プログラムの不具
合をバグ（bug）、バグを取り除くことをデバッグ（debug）、バグの原因を突き
止める作業をデバッギング（debugging）、デバッギングの手助けをするツールを
デバッガ（debugger）、ついでにデバッギングされるプログラムのことをデバッ
ギ（debuggee）といいます。クラッカ達は「ある日付を超えたら動作しなくなる
バグ」や「シリアル番号を入力しないと機能に制限があるバグ」などを、様々な
ツール（そのうちのひとつがデバッガ）を使って、「何故そのような動きになる
のか」を調査して(デバッギング)、取り除いてしまいます（デバッグ）。

　そこで今回の目的は、アプリケーションデバッガでブレイクポイントを設置し
たりAPIコールで停止させて引数を調べたりスタックフレームを調べてバグの箇所
を推定したりすることを防ぐことになります。以後、いちいちアプリケーション
デバッガと書くのは面倒なので「デバッガ」と表記した場合は「アプリケーショ
ンデバッガ」を指すこととします。

●使用するファイル

・http://wizardbible.org/32/AntiDebugging.v3.zip
・http://wizardbible.org/32/DebuggerSample.zip


■0x02.) どうやって防ぐのか

　よくあるのがデバッガが検出された場合プログラムを終了させてしまうという
ものです。デバッガの検出方法はDegital Travesiaの『OllyDbg』Q&A（http://h
p.vector.co.jp/authors/VA028184/OllyDbgQA.htm）に記載されていますのでそち
らをどうぞ。他にもgoogleなどで「detect debugger」や「anti debugging」など
をキーワードに検索するとたくさんひっかかります。
　しかしこの方法はあまり効果がありません。クラッカにしてみればデバッガの
検出部分を調べて取り除いてしまえばよいだけの話です。デバッガの検出は決ま
りきった処理のため突き止めるのも簡単です。デバッガ検出部分を巧妙に隠して
あるようなものもありますが生半可な知識で仕込んでも熟練のクラッカ相手には
3分ともたないでしょう。

　そこで今回紹介するのが「デバッギングされてしまうのが嫌なら自分が先にし
てしまえ」という方法です。
　デバッガは最初に「このプロセスを私にデバッギングさせてください」とWind
owsにお願いしなければいけません。このとき、ターゲットプロセスが他のデバッ
ガによって既にデバッギングされていた場合、そのお願いは却下されてしまいま
す。「こいつ（デバッギ）にはもう恋人（デバッガ）がいるので諦めなさい」と
いわれるのです（XPやVistaにはその恋仲を壊してしまう方法もあったりしますが）。
　したがって、デバッギングされたくないプロセスがあるなら、自分が先にその
プロセスをデバッギングしてしまえばよいことになります。ただし、自プロセス
をデバッギングすることはできませんので、デバッガ担当とデバッギ担当（実作
業担当）にプロセスを分けて動作させます。デバッガ担当はデバッギングされて
しまいますが、実作業担当のほうはデバッギングすることができなくなります。


■0x03.) デバッガの基礎

　さて、先にデバッギングしてしまえばよいというのは簡単ですが、デバッガと
なるにはいくつかの手順や決まりがあります。

　デバッガの基本的な構造は次のようになっています。

①新規プロセスをデバッギとして生成(または既存プロセスをアタッチ)
②デバッグイベントを待機
③デバッグイベントを処理
④続行方法を指定してスレッドを再開
⑤②へ戻る

　各々のステップを順を追って説明していきます。

①プロセスをデバッギとして生成(または既存プロセスをアタッチ)

　前述した「ターゲットプロセスを私にデバッギングさせてください」とWindow
sにお願いする部分です。CreateProcess()APIでプロセスを新しく生成する時にD
EBUG_PROCESSフラグを指定すると新しく作られるプロセスはデバッギとなり、デ
バッギプロセスを生成したデバッガにとってデバッギング対象となります。
　DEBUG_PROCESSフラグだけではデバッギが作った子プロセスもデバッギング対象
となります（ただし、子プロセスの生成にDEBUG_PROCESSフラグを指定した場合を
除く)。DEBUG_ONLY_THIS_PROCESSフラグを指定すると子プロセスはデバッギング
対象外となります。
　既存プロセスをデバッギングしたい場合はDebugActiveProcess()APIを使います。
その場合、子プロセスはデバッギング対象外となります。

②デバッグイベントの待機

　デバッギの実行中に例外が発生したりDLLをロードしたりするとデバッグイベン
トとしてデバッガ側に伝えられます。デバッグイベントは例外発生、プロセスの
生成・終了、スレッドの生成・終了、DLLのロード・アンロードに分類され、例外
発生はブレイクポイントへの到達（INT 3の実行）やアクセスバイオレーションな
どさらに細かく分類されます。
　デバッギの起動時またはアタッチ時には必ずブレイクポイント例外が発生しま
す（このブレイクポイントはAPIが設置したものでその場所はエントリポイントで
はありません）。これをファーストチャンスイベントと言い、この時にブレイク
ポイントの設置など初期化を行います。
　デバッグイベントの待機にはWaitForDebugEvent()APIを使います。

③デバッグイベントを処理

　デバッグイベントがデバッガに伝えられるとデバッギの全スレッドが停止状態
になります。これを利用してメモリの内容やスタックの状態を表示したり、デバ
ッギが処理を続けられるように例外の処理を行います。また、デバッギが終了し
た場合、つまりデバッグイベントがこれ以上発生しなくなった場合には、デバッ
グイベント待機のループから抜けないとデバッガがいつまでたっても終了しない
ことになります。

④続行方法を指定してスレッドを再開

　デバッグイベント処理中はデバッギの全スレッドが停止状態にあるわけですか
ら、処理が終わったことをWindowsに伝えて、デバッギの全スレッドを再開させて
やらなければいけません。この時、例外をデバッギの例外ハンドラに渡すかどう
かを指定します。ただし例外発生以外のデバッグイベントではこの指定は無視さ
れます。
　この例外を渡すかどうかの指定をデバッガは適切に判断しなければいけません。
例外をデバッギの例外ハンドラで処理しなければいけないのにデバッガでブロッ
クしてしまうと同じデバッグイベントが無限に発生したり、デバッガが設置した
ブレイクポイントへの到達をデバッギの例外ハンドラに渡してしまうと強制終了
してしまう可能性があります。
　Digital Travesiaに記載されている「6.構造化例外ハンドラを用いたデバッグ
検出」（http://hp.vector.co.jp/authors/VA028184/OllyDbgQA.htm）で検出され
るようなデバッガは適切に判断していないデバッガです。適切な判断をするデバ
ッガは検出されません。サンプルプログラムDebuggerSample.zipを用意しました。
debuggee.exeは「構造化例外ハンドラを用いたデバッグ検出」とIsDebuggerPres
ent()APIの戻り値の表示を行います。debugger.exeはdebuggee.exeをデバッギと
して起動して、ブレイクポイント例外が発生した場合に例外をデバッギに渡すか
どうか確認してきます。渡すかどうかでその後の処理の違いを確認してください。


■0x04.) デバッガの実装

　ここまで説明すれば後はソースファイルを見たほうが早いでしょう。C言語で記
述すると次のようになります。

----------------------------------------------------------------------------
DEBUG_EVENT de = { 0 };			// デバッグイベント情報
STARTUPINFO	si = { 0 };			// CreateProcess() から戻される情報
PROCESS_INFORMATION pi = { 0 };	// CreateProcess() から戻される情報
// プロセスをデバッグ対象として生成する
BOOL bCreate = CreateProcess(
	NULL					// lpApplicationName
,	"debuggee.exe"			// lpCommandLine
,	NULL					// lpProcessAttributes
,	NULL					// lpThreadAttributes
,	FALSE					// bInheritHandles
,	DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS	// flags
,	NULL					// lpEnvironment
,	NULL					// lpCurrentDirectory
,	&si						// lpStartupInfo
,	&pi);					// lpProcessInformation
if( bCreate == FALSE )
{
	return 1;
}

// デバッグイベントの待機
while( WaitForDebugEvent(&de, INFINITE) )
{
	// スレッドの続行方法
	DWORD dwContinueStatus = DBG_CONTINUE;	// 初期値は例外をデバッギに渡さない

	// 例外発生
	if( de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT )
	{
		EXCEPTION_RECORD* per = &de.u.Exception.ExceptionRecord;

		// ブレイクポイントに到達
		if( per->ExceptionCode == EXCEPTION_BREAKPOINT )
		{
			// ファーストチャンスイベント
			if( bFirstChance )
			{
				bFirstChance = FALSE;
				// ブレイクポイントの設置など初期化を行う
			}
			else
			{
				// 身に覚えのないブレイクポイントはデバッギに処理させる。
				dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
			}
		}
		// その他の例外処理
		else
		{
			// デバッギの例外ハンドラに例外を処理させる。
			dwContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
		}
	}
	// プロセスが終了した
	else if( de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT )
	{
		// デバッグイベントの待機を辞める。デバッギの子プロセスを含めて
		// デバッグ対象としている場合は全てのプロセスが終了するまで処理
		// を続ける
		break;
	}
	// その他、DLLのロード/アンロード、プロセスの生成、スレッドの生成/終了
	//else
	//{
	//}

	// 続行方法を指定してスレッドを再開
	if( !ContinueDebugEvent(de.dwProcessId
		, de.dwThreadId, dwContinueStatus) )
	{
		break;
	}
}

// プロセスハンドルとスレッドハンドルをクローズする
CloseHandle(pi.hProcess);
CloseHandle(pi.hThread);
----------------------------------------------------------------------------


■0x05.) アンチデバッギングの実装

　デバッガの骨組みが出来たところでアンチデバッギングの実装に取り掛かりま
す。前述したようにデバッガ担当とデバッギ担当（実作業担当）にプロセスを分
けて動作させます。しかし、プログラムをデバッガ担当とデバッギ担当に分ける
必要はありません。Cランタイムスタートアップルーチン（WinMainCRTStartup）
が実行される前にデバッガ部分が実行されるようにして、次の手順を行います。

①自プログラムをデバッギとして起動
②ファーストチャンスイベントでエントリポイントにブレイクポイントを設置
③エントリポイントに設置したブレイクポイントに到達したらオリジナルエント
リポイント（WinMainCRTStartup）にジャンプ

　ブレイクポイントの設置とは、設置したい場所のプログラムコードを0xCC（IN
T 3のマシン語コード）に変更することです。また、オリジナルエントリポイント
へのジャンプはスレッドのCPU状態（CONTEXT）を操作するGetThreadContext()AP
IとSetThreadContext()APIを使って現在実行中のアドレス（EIP）を変更します。
これを実装したのがAntiDebugging.cです。デバッギングを防止したいプログラム
のプロジェクトにAntiDebugging.cを追加し、プロジェクトの設定でエントリポイ
ントをEntryPointにするだけでデバッギングが防止できます。サンプルとしてAn
tiDebugging.v1.zipを用意しましたので、OllyDbgなどでデバッギングを試してみ
て下さい。ブレイクポイントは上手く機能しないし、既存プロセスのアタッチも
失敗します。


■0x06.) 簡単に解除されてしまうアンチデバッギング

　確かにデバッギングが防げましたが、これを簡単に解除してしまうことができ
ます。

①SetThreadContext()APIにブレイクポイントを設置。
②①で設置したブレイクポイントに到達したら、APIに渡された引数のCONTEXT構
造体のEipの値を控える。
③プログラムのエントリポイントを②のEipの値で書き換える。

　たったこれだけです。これはデバッガ部分がデバッギをオリジナルエントリポ
イントにジャンプさせるだけの役割しか果たしていないからです。これを防ぐに
はデバッガ部分が動作しないとデバッギが動作しないようにしてやる必要があり
ます。次回はその方法と説明を行います。


■0x07.) 最後に

　前回のPackedFileLoaderではPEフォーマットの知識ありきで説明してしまった
ためかなり説明を省いてしまいましたが、今回はいかがでしたでしょうか。ほと
んどデバッガの説明で終わってしまった気もしますが、デバッガの仕組みを理解
するのはとても重要なことです。アンパック後に逆アセンブルするdispeやジェネ
リックアンパッカなどもデバッガなので対策をたてる上で役にたつからです。例
えば親プロセスのプログラムがWaitForDebugEvent()APIをインポートしている場
合はデバッガがアタッチされていると判断できます。自分でもいろいろと考えて
みてください。


