x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: はじめてのハッキング　〜ハードウェアの基礎〜 ---

著者：Defolos

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　今回も基礎知識の確認を行います。プログラムの動作を物理的に実現するハー
ドウェアの基礎知識を確認します。バッファオーバフローやその他のハッキング
技術と特に関係性の深いメモリとCPU（演算装置）の動作を中心に説明します。
　ハッキングというとソフトウェアの話であって、ハードウェアとはまったく関
係が無いと思われがちです。しかし、実際にはハードウェアの特性を知った上で、
その設計上のミスをうまく利用する必要があります。ゆえに、ハードウェアに対
する理解は決して軽視するべきものではありません。
　ですので、今回はハードウェアについて簡単におさらいしてみましょう。


■0x02.) コンピュータの5大装置

　コンピュータはいくつかの機能を持つ装置が寄り集まってできています。コン
ピュータには主に入力機能、記憶機能、演算機能、出力機能、制御機能の5つの機
能が備わっており、それぞれの装置が機能を実現しています。

              +--------+
    +^^^^^^^^^|制御装置|^^^^+^^^^^^^^^+
    ^         +--------+    ^         ^
    ^           ^ ↑        ^         ^
+---^----+   +--^-----+     ^    +----^---+
|入力装置|-→|記憶装置|-----^--→|出力装置|
+--------+   +--------+     ^    +--------+
                ↓  ↑      ^
             +--------+     ^
             |演算装置|^^^^^+
             +--------+

*  ------ ：データの流れ
*  ^^^^^^ ：制御の流れ

●入力装置

　データやプログラムを取り込むための装置です。キーボードやマウスとしてユ
ーザからの命令を受付たり、ハードディスクからプログラムを読み込むための装
置です。

●記憶装置

　記憶装置は主記憶装置と補助記憶装置に分けられます。主記憶装置はメインメ
モリと呼ばれ、プログラムを一時的に記憶してCPUへ引き渡す役割を持ちます。主
記憶装置は値段の問題や容量、電源を切るとデータが消える（発揮性）ために補
助記憶装置とあわせて使用する必要があります。補助記憶装置はHDDやCD-R、フラ
ッシュメモリなどが挙げられます。人に例えるなら、CPUが脳の考える部分、メイ
ンメモリが脳の記憶部分、補助記憶装置がノート・メモに例えられます。

●演算装置

　CPU（Central Professing Unit）と呼ばれる装置です。実際の演算を行う装置
であり、計算・比較・判断などを行います。演算装置には情報を保持しておく機
能はないので、記憶装置を用いて演算する情報を保持します。

●出力装置

　計算結果などをユーザに通知する装置です。ディスプレイやプリンターなどが
挙げられます。

●制御装置

　他のすべての装置に働きかけ、データの流れの制御などを行います。CPUとして
実装されていることが多い装置です。

　これらの機能を理解するには、人に置き換えて考えると分かりやすいです。算
数の授業で「5+4はいくつか」という命題が黒板に書かれて与えられたとします。
まず、私たちは黒板を目で見て問題を脳に取り込みます。目が入力装置の役割を
果たしたことになります。次に、脳に命題を記録するのは命題が長くなるにつれ、
あやふやになりかねないのでノートに「5+4=」と書き写します。このノートが主
記憶装置の役割を果たすことになります。次に、頭の中に5と4という数字を記憶
し、その2つの数字を足すという操作を頭の中で行います。ここで、脳が演算装置
の役割を果たしました。演算結果として得られた9という数字をノートに書き写し
ます。最後に、前に出て黒板に9と書くことで命題を解いたことになります。黒板
に書くという動作が出力装置の役割を果たしたことになります。
　このように、コンピュータは人が普段から行っている動作を高速で行っている
に過ぎません。


■0x03.) メモリの概要

　メモリはコンピュータの5大機能のうち、記憶機能を担うハードウェアです。H
DDなどの補助記憶装置に保存されているプログラムは、必ず一度メモリ上に展開
されてから実行されます。メモリの構造とバッファオーバフローは非常に関連性
が強いため、メモリの構造を理解した後にバッファオーバフローの解説を読むこ
とをおすすめします。

　メモリは先述の例でも挙げたように、データや命令を一時的に記憶しておく装
置です。すべてのデータ・命令は一端メモリに格納され、どのような順番でどの
ような命令を実行するかが展開されます。メモリの内容を書き換えることで任意
のプログラムを実行し、権限を取得するのがハッキングの目的です。

●ノイマンアーキテクチャ

　コンピュータ科学で最も有名な人物を挙げるとしたら、まずはじめに名が上が
るほど有名なジョン・フォン・ノイマンという人物がいます。ノイマンアーキテ
クチャとは、このノイマンが考え出したコンピュータハードの設計概念です。現
在のコンピュータは少数の例外を除いてはすべてノイマンアーキテクチャを採用
しています。
　ノイマンアーキテクチャはプログラム記憶型とも呼ばれ、プログラムをメモリ
に格納して実行するタイプのアーキテクチャを指します。このアーキテクチャが
考案されるまではプログラムはコンピュータの物理的配線によってしか書き換え
ることができませんでした。これでは、違う処理をさせるごとに配線を変えなけ
ればならず面倒です。
　ノイマンアーキテクチャの特徴として、バッファオーバフローを考える場合に
注目すべき特徴があります。ノイマンアーキテクチャでは、メモリに格納された
命令とデータを区別しないというバッファオーバフローによる権限奪取に好都合
な特徴をもっています。例えば、「20+5の計算結果を表示する」という命令を12
34と定義したとします。もしデータを読み出す命令によって「1234」が参照され
たとすると、1234は千ニ百三十四という値として扱われます。一方、命令として
「1234」が参照されると、これは「20+5の計算結果を表示する」という命令だと
解釈され画面に25が表示されます。つまり、データを格納する場所に命令として
意味のある数値を格納し、この数値を命令として参照することで任意の命令を実
行することができます。

●メモリの構造

　ノイマンアーキテクチャではメモリに格納された命令とデータは区別しないと
書きましたが、メモリはデータと命令を一緒くたに記憶しているわけではありま
せん。データはデータを格納する場所に置かれ、命令は命令を格納する場所に置
くというように、ものによって格納する場所を変えています。命令とデータの扱
いは同等であっても、格納する場所は分けられているということです。この場所
のことをセグメントと呼び、Intel x86アーキテクチャではテキストセグメント、
データセグメント、bssセグメント、ヒープセグメント、スタックセグメントの5
つのセグメントが存在します。

+------------------+ 0x00000000
|                  |
| Text Segment     |
|                  |
+------------------+
|                  |
| Data Segment     |
|                  |
+------------------+
| dss Segment      |
+------------------+
| Heap Segment     |
:                  : ↓
                     ↓
+------------------+
                     ↑
:                  : ↑
| Satck Segment    |
+------------------+ 0xffffffff


　それぞれのセグメントの役割は次の通りです。

○テキストセグメント

　コードセグメントとも呼ばれます。テキストセグメントは命令を格納するため
のメモリ領域です。例えば「a=3; b=5; x=a+b;」というプログラムがあったとし
ます。3や5といった数字はデータであり、別の領域に格納されますので、3が格納
されている場所をADDRESS_3と置きます。テキストセグメントには「aにADDRESS_3
を移動させる」、「bにADDRESS_5を移動させる」、「b+cを計算する」、「xにそ
の結果を移動させる」といった命令自体が格納されます。命令が操作するデータ
は他の領域に格納されるため、ここに格納されるのはデータを抜きにした命令の
流れだけです。
　テキストセグメントに格納された命令は、OS以外が書き換える必要はありませ
ん。初めにOSが命令を格納し、実行がすべて終わったら格納された命令をクリア
する以外にテキストセグメントの内容に触る必要はないため、このセグメントへ
格納された内容をプログラムによって書き換えることはできません。書き換えが
行われないため、テキストセグメントのサイズは固定長です。

○データセグメント

　データセグメントには初期化済みのグローバル変数や静的変数、文字列や定数
などのリテラルが格納されます。変数の中でもプログラムの実行を通して変化す
ることのない、定数的な変数または定数を格納するのがこのセグメントです。定
数を格納するのセグメントですので、プログラムによるセグメント内の書き換え
は禁止されています。書き換えが発生しないため、このセグメントも固定長のサ
イズです。

○bssセグメント

　bssセグメントは初期化されていないブローバル変数や静的変数などが格納され
ます。

○ヒープセグメント

　プログラム内で動的にデータ領域が確保される場合に利用されます。C言語では
malloc()などで確保される領域がヒープセグメントにあたります。必要に応じて
プログラム内で領域確保・解放されるため、ヒープセグメントは確保量にあわせ
て増減します。後述するスタックも同じような性質を持ちますが、ヒープセグメ
ントはメモリの低位アドレスから高位アドレス方向へ伸びていきます。

○スタックセグメント

　スタックセグメントはバッファオーバフローで最も狙われるセグメントです。
スタックについては後述しますが、スタックセグメントはメモリ上にスタック構
造を実装した領域です。C言語で書かれたAuto変数（デフォルトの変数）や関数呼
びだし時の戻りアドレス、関数内で宣言した変数などはすべてスタックセグメン
ト上に確保されていきます。
　スタックセグメントはプログラムの実行に伴って書き換えられる可能性がある
ため、サイズは非固定長です。先述のヒープセグメントと同じように増減します
が、スタックセグメントはメモリの高位アドレスから低位アドレスへ徐々に伸び
て増加します。

●メモリのアドレス

　メモリは1バイトごとに番号が振られています。これは駅のロッカーを想像して
もらうと分かりやすいと思います。ロッカーには通常、ロッカー番号がつけられ
ています。荷物をいれたロッカーの番号を覚えているので、私達は後で預けた荷
物を取り出すことができます。メモリはロッカーひとつに1バイトの荷物をいれる
ことができるロッカースペースだと思ってもらえればよいです。

+-[1]-----+-[2]----+-[3]----+-[4]----+-[5]----+
|         |        |        |        |        |
+-[6]-----+-[7]----+-[8]----+-[9]----+-[10]---+
|         |        |        |        |        |
+---------+--------+--------+--------+--------+

　このロッカーにデータを格納する時の事を考えてみます。C言語のint型データ
は4バイトの大きさだと定義されていますので、int型データひとつをメモリに格
納するには4アドレスが必要となります。駅のロッカーの例では、ロッカーひとつ
では入り切らないほどの荷物を預けたい場合、入り切らなかった分を隣のロッカ
ーに預けます。これと同じことをやっています。

+-[1]-----+-[2]----+-[3]----+-[4]----+-[5]----+
|  int型の荷物（ロッカーを4つ使う）  |        |
+-[6]-----+-[7]----+-[8]----+-[9]----+-[10]---+
|         |        |        |        |        |
+---------+--------+--------+--------+--------+


■0x04.) 演算装置の概要

　演算装置は本来、CPUの算術論理演算ユニット（Arithmetic and Logic Unit：
ALU）が担当する、計算だけを行う機能のことを指しますが、ここでは制御装置も
含めたCPUとしての演算装置について言及します。

●演算装置の構造

　演算装置は複数の機能を実現する部品が組み合わされて構成されています。こ
こでは代表的な部品について説明します。

○算術論理演算ユニット

　数値演算および論理演算を行うだけの装置です。演算に使うデータや「足す」、
「引く」などの操作や計算結果を記憶しておくことはできません。例えば、私達
も「2+4」の計算をする時、まず頭の中に2と4を記憶します。その後に加算という
概念を2と4に適応することで6が出てきます。結果として6を頭の中に覚えておく
ことで計算を終えます。
　つまり、計算をするためには一時的に数値を記憶する仕組みが必要です。次に
挙げるレジスタという装置がその役割を果たします。

○レジスタ

　一時的な数値の記憶を行います。メモリとは違い、非常に高速ですが容量を多
くすることはできませんし、記憶容量当たりの単価も高価です。そのため、通常
は32ビットのレジスタが10個ほどしか用意されていません。
　このレジスタは役割があらかじめ決められています。

・EIS：次に実行すべき命令の場所を保存
・ESP：スタックセグメントの端の場所を保持
・EAX：システムコール番号を格納
・EBX：システムコールに渡す第1引数を格納
・ECX：システムコールに渡す第2引数を格納
・EDX：システムコールに渡す第3引数を格納
・命令レジスタ：解釈した命令を一時保存

　このうち、EIPの中身は命令が実行されるたびに次の命令のアドレスに置き換わ
り、ESPの内容は後述するスタックのプッシュ・ポップの状況似合わせて増減しま
す。レジスタの名前や機能、個数はCPUメーカーによって様々ですが、本レポート
ではIntelのx86系のCPUを対象としています。CPUの種類によってはEISをプログラ
ムカウンタと呼んだりします。

○キャッシュ

　メモリより高速ですが高価な記憶素子を使った一時記憶装置です。最近使われ
たデータはもう一度使われる可能性が高いので、一度使われたデータはメモリよ
り高速なキャッシュに保存されます。
　演算装置内に実装するキャッシュは容量が多いほど不良品が出やすいので、CP
Uの価格の差のほとんどがキャッシュの容量に左右されます。

○内部バス

　レジスタと算術論理演算ユニットの間のデータのやり取りを行うための通信線
です。コンピュータの動作速度に大きく関与します。

●マシン語の命令実行

　プログラムは全てマシン語で表現され、メモリに格納されることはすでに述べ
ました。CPUはメモリから順次機械語命令を読み出し、その通りに実行します。正
確には、CPUは、レジスタとしてCPU内部に存在するプログラムカウンタ（Intelx
86ではEIP）内に保持されたメモリアドレスにある命令を次の実行すべき命令とし
て取り扱います。例えば、次の図ではプログラムカウンタ内には「0x00ffffa0」
という値が保持されています。次の命令実行時には、このプログラムカウンタを
一度読み出し、内部に格納されている「0x00ffffa0」のメモリアドレスに格納さ
れている「0x00ffffa3」という機械語を命令として実行します。

+---[ProgramCounter]---+      +---[Memoly]---+
|      0x00ffffa0      |--+   |   0x00f1120f | 0x00ffff9f
+----------------------+  |   +--------------+
                          +-→|   0x00ffffa3 | 0x00ffffa0 ---+
                              +--------------+               |
                              |   0x004ca300 | 0x00ffffa1    |
                              +--------------+               |
+--------[ALU]---------+      |   0x00cf8880 | 0x00ffffa2    |
|                      |      .              .               |
|       0x00ffffa3     |←-----------------------------------+
+----------------------+

　正確に言うなら、プログラムカウンタから読み出した命令は算術論理演算ユニ
ットで実行される前に、デコーダという装置で解釈されます。これは命令が足し
算なのか引き算なのか何なのかを判断し、演算対象となるデータがどこにあるの
かを計算します。命令自体は命令レジスタに格納されているので、そこから読み
出します。

+---[Instaction Registor]---+
|        0x00ffffa3         |
+---------------------------+
             |
             |
             |
      +=============+
      +==[Decoder]==+ .....targer1=eax; target2=ebx;
      +=============+ .....a3 is additional
             |
             |
             |
    +------[ALU]------+
    |  x = x  +  y    | .....location of x: eax
    +-----------------+ .....location of y: ebx

　上図では0x00ffffa3をデコーダが解釈し、a3が足し算であることを知り、ffff
がeaxにebxとの計算結果を格納すると知ります。次に足し算の実行が行われます
が、算術論理演算ユニットはデコーダで得られたデータの場所へデータを取得し
に行きます。ここではeaxとebxレジスタを参照します。


■0x05.) スタック

　スタックとは情報科学の分野でよく用いられるデータの構造概念です。この構
造をCPU内に実装したものをスタックセグメントと呼びます。

●スタック構造

　スタックはショッピングセンターのカートのようなもので、後にいれたものか
ら順番に取り出すデータ構造です。最後にいれたものから取り出すという性質か
らLIFO（Fast In First Out）またはFILO（First In Last Out）型のデータ構造
だと言われます。カートの例で説明しますと、まずカートはレジ横の設置場所に
数台設置されいるとします。

[設置場所] <<<<<

　買い物をするときはカートをひとつ取り出して商品をカートにいれて行きます
が、通常カートは一番上（最後い入れられたカート）から取り出します。真ん中
のカートを無理やり取り出す人は極少数派なはずです。「●（黒丸）」を消費者
だとします。左に向けてカートが積まれるとしますと、消費者は一番右にあるカ
ートをつかんで持って行きます。

[設置場所] <<<<<●←

[設置場所] <<<<  →<●

　もう一人消費者が来たとしたら、同じように一番右にあるカートを持って行き
ます。このようにスタックからデータ（カート）を取り出すことをポップ（Pop）
と言います。

[設置場所] <<<  →<●

　一方、買い物が終わってカートを返す時のことを考えて見ましょう。これも普
通の人は一番右にいれて行くはずです。よほどポリシーを持った人でなければ、
真ん中の方に無理やり挿入することは考えにくいです。

[設置場所] <<< <●←

[設置場所] <<<<●←

　このようにスタックにデータを挿入する動作をプッシュ（Push）と言います。
これをより一般的に書くと次のような図として書き表すことができます。

    [Stack]              [Pop]               [Push]
                     +------------+
                     |      2     |
                     +------------+
                            ↑                ↓
+              +    +       ↑     +    +     ↓       +
|              |    |       ↑     |    |     ↓       |
+--------------+    +       ↑     +    +--------------+
|      2       |    |       ↑     |    |      3       |
+--------------+    +--------------+    +--------------+
|      1       |    |       1      |    |      1       |
+--------------+    +--------------+    +--------------+

　一番左が初期状態です。1と2の値が入っています。このスタックに対して左か
ら2つ目のようにポップ作業を行うと、一番上にある2が取り出されます。次に一
番右のように3をプッシュすると、前回の操作で2が取り出されたので、残った1の
上に3が入れられます。

●関数呼び出しとスタック

　関数を呼び出す時には、OSはいくつかの作業を行ってプログラムの制御を呼び
出される関数へ変更します。関数の処理が終わった場合にもいくつか作業を行い、
以前実行していた場所に制御を戻します。このときにスタックを大いに活用して
います。
　実際に行っている作業は次のステップに分けられます。

1:ESPの場所へスタックフレームをプッシュする
2:EIPの値を、呼び出す関数の開始アドレスに変更
3:EIPにあるアドレスを解釈し順次実行する
4:関数が終わりに達したらスタックフレーム内のRETをEIPに変更
5:一番上にあるスタックフレームの除去

●スタックフレーム

　スタックフレームは関数を呼び出して利用する時に必要となる情報をひとまと
めにしたものです。スタックフレームは戻りアドレスや引き数などで構成されて
います。構成は次の図のようになっています。

+----------------------------+
|  ローカル変数              |
+----------------------------+
|  退避済みフレームポインタ  |
+----------------------------+
|  戻りアドレス              |
+----------------------------+
|  引数                      |
+----------------------------+

○引数

　関数への引数はスタックフレームの一番下に位置します。また、スタック構造
であるため、最も後に宣言した引数ほど先にスタックフレームに格納されます。

○戻りアドレス

　関数の処理が終了した場合に制御を移すべきアドレスです。関数呼び出し時の
EIPの値です。関数が終わりに達したら、この戻りアドレスを参照しEIPに格納し
ます。その結果、制御が関数を呼び出す前の場所に戻ってくるわけです。

○退避済みフレームポインタ

　関数呼びだし前のEBPの値です。関数の終了時にEBPの値を元に戻すのに利用さ
れます。EBの値がスタックにプッシュされた後には、この関数のフレームポイン
タを設定するために現在のESPの値がEBPに設定されます。EBPとのオフセットを減
算することでローカル変数を参照することができ、逆に加算することで引数を参
照することができます。

○ローカル変数

　ローカル変数は関数内で宣言される変数のことです。ローカル変数はスタック
フレームの最も上に格納されます。引数と同じように、スタック構造であるため、
後に宣言した変数ほど先に格納されます。ローカル変数はEBPを用いて参照されま
す。具体的にはEBPとどれだけ離れているかを計算することでアクセスが可能とな
るのです。

　次のプログラムでは、main関数内から4行目でfunc関数を呼び出しています。呼
び出した後に元の場所に制御を戻すということは、func関数が実行された後にma
in関数の5行目のreturn命令を実行することになります。

-----
int main(void){

    int x, y;
    y = func(x, 2);
    return 0;
}

int func(int x, int y){

    char test;
    test = x + y;
    return x * test * y;
}
-----

　この場合、次のようなスタックフレームがスタックセグメントにプッシュされ
ます。スタックセグメントは高位アドレスから低位アドレスへ伸びるので、デー
タは0xffffffffから0x00000000の方向へ積まれていきます。ESPはスタックセグメ
ントの最も小さい方の端のアドレスを保持するレジスタなので、スタックフレー
ムがプッシュされると、そのサイズ分だけ低位アドレスに移動します。

+-----------------------------+0x00000000
:                             :
:                             :
+-----------------------------+0xfffffff9 ← content of ESP
|                             |
+-----------------------------+0xfffffffa
|             test            |
+-----------------------------+0xfffffffb
|                             |
+-----------------------------+0xfffffffc
|             RET             |
+-----------------------------+0xfffffffd
|             x               |
+-----------------------------+0xfffffffe
|             y               |
+-----------------------------+0xffffffff

　EIPの値や引き数、ベースポインタの値などをスタックに一時保存することで、
以前実行していた命令の場所を覚えておくことができます。つまり、関数による
構造化プログラミングのような近代的プログラミングテクニックを活用するのに
当たって、スタックセグメントは必要不可欠です。しかし、Intelのx86アーキテ
クチャはスタックへ格納される情報の順番に問題があるため、バッファオーバフ
ローの危険性が存在するのです。この危険性については次回のレポートでハッキ
ングの実例を挙げて解説します。


■0x06.) 参考文献

・「Hacking：美しき策謀」　Jon Erickson著　村上 雅章訳　ISBN4-87311-230-3
　http://www.oreilly.co.jp/books/4873112303/

・「ハッキング対策マニュアル」ISBN4-7973-2145-8

・「セキュリティ夜話　バッファオーバーフロー（BO)系列　（１）Aleph Oneに
よるスタック破壊の楽しみと恩恵」
　http://www.asahi-net.or.jp/~vp5m-snd/sec/tech/Phrack49-14.html

・初心者のためのポイント学習Ｃ言語
　http://www9.plala.or.jp/sgwr-t/


■0x07.) さいごに

　今回は前回に引き続き、前提知識の確認を行いました。ハッキングにおいて特
に本質となるプログラミングを重点にC言語とアセンブリ言語について解説をしま
した。次回はハードウェアについての基礎部分を解説し、前提知識の確認を終え
ます。まだ、いかにもハッキングといった内容の解説は出てきませんが、前提と
なる知識を詰めることがハッキングの理解を助けるのだと考えています。
　それでは、またお会いしましょう。


