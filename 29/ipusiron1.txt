x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x

--- 第○章: 基礎暗号学講座 〜 第4回 〜 ---

著者：IPUSIRON

x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x
x0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0xx0xXx0x


■0x01.) はじめに

　前回のWBではブロック暗号の利用モードとして、ECBモードとCTRモードの2つを
解説しました。今回は残りのCBCモード・CFBモード・OFBモードについて解説する。
そして最終的にどの利用モードを採用するほうがよいのかを言及します。


■0x02.) CTRモードの問題の答え合わせ

　前回のWBの第4章の0x07において、CTRモードと情報理論的な安全性についての
問題を出しました。まず新しいことを学ぶ前に軽く復習しておきましょう。全然
意味がわからないという方は気軽に雑談掲示板に質問してください。実際きちん
と追っていけばそれほど難しいことはしていません。

問：CTRモードについて、次の設問を解け。
（1）平文M=(m_1,m_2)に対する暗号文がC=(ctr,c_1,c_2)であった。このときの
E_k(ctr+1)およびE_k(ctr+2)の値を求めよ。
（2）ランダム関数族をブロック暗号として用いるCTRモードを考える。アタッカ
ーが暗号文C=(ctr,c_1,c_2)を入手した。このとき、平文が(m_1,m_2)である確率
を求めよ。
（3）ランダム関数族をブロック暗号として用いたCTRモードは、情報理論的に安
全であることを証明せよ。
（4）ランダム置換族をブロック暗号として用いるCTRモードを考える。アタッカ
ーが暗号文C=(ctr,c_1,c_2)を入手した。このとき、平文が(m_1,m_2)である確率
を求めよ。
（5）ランダム置換族をブロック暗号として用いたCTRモードは、情報理論的に安
全でないことを証明せよ。


　まず（1）から解いていきます。カウンターモードの暗号化では、平文M=(m_1,
…,m_t)に対して、c_1=m_1+E_k(ctr+1),…,c_t=m_t+E_k(ctr+t)を計算します。わ
かりやすいように縦に並べてみましょう。

c_1=m_1+E_k(ctr+1)
c_2=m_2+E_k(ctr+2)
…
c_t=m_t+E_k(ctr+t)

　ただし問題の中では平文はm_1とm_2だけなので実質2つの式だけしかありません。

c_1=m_1+E_k(ctr+1)
c_2=m_2+E_k(ctr+2)

　ここで+はXOR演算であることを思い出します。XOR演算の特徴として同じものを
足し合わせると消えるというのがあります。例えば6+6=0になるわけです。2進数
で考えればこれは明らかです。101と101をXOR演算したとします。XOR演算は0+0=
0,0+1=1,1+0=1,1+1=1であるので、101+101=000になります。

　上に列挙した中で一番最初の式を変形していきます。

c_1=m_1+E_k(ctr+1)
c_1+m_1=m_1+m_1+E_k(ctr+1)　（∵両辺にm_1をXOR演算する）
c_1+m_1=E_k(ctr+1)　（∵m_1+m_1=0）
E_k(ctr+1)=c_1+m_1　（∵右辺と左辺を入れ替えた）

　同様に2番目の式を変形していきます。

c_2=m_2+E_k(ctr+2)
E_k(ctr+2)=c_2+m_2

　次に（2）を解きます。（2）の問題文が云わんとすることは、「M=(m_1,m_2)∧
C=(ctr,c_1,c_2)」が成り立つ確率を求めなさいということです。つまり、次のよ
うに計算していくことができます。

Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))
=Pr(E_k(ctr+1)=c_1+m_1,E_k(ctr+2)=c_2+m_2)
=Pr(E_k(ctr+1)=c_1+m_1)・Pr(E_k(ctr+2)=c_2+m_2)
=(1/2^n)・(1/2^n)
=1/2^(2n)

　ところで、数学の問題が小さい問が連続して出題されているときは、前の問題
がヒントになっていることが多いです。ここでも（1）の答えを使って、上記の式
変形の1つ目から2つ目に式変形しています。
　3つ目から4つ目の変換で実際に確率計算しています。前半の「Pr(E_k(ctr+1)=
c_1+m_1)=1/2^n」部分を見ていきましょう。c_1やm_1はnビットなので、それをX
OR演算したc_1+m_1はnビットです。つまりc_1+m_1の総パターンは2^n通りです。
これがE_k(ctr+1)とちょうど一致するのは、1/2^nとなります。後半のPr(E_k(ct
r+2)=c_2+m_2)=1/2^n」部分も同様に考えればよいです。

　それでは（3）を解きます。その前に情報理論的に安全という意味を復習してお
きましょう。前回のWBから抜粋しておきます。

[定義]
∀c∈C、∀m∈M；Pr(~M=m|~C=c)=Pr(~M=m)
が成り立つとき、暗号系（~K,~M,~C）は情報理論的に安全（完全秘匿）であると
いう。

（図）http://s-akademeia.sakura.ne.jp/main/image9/jyouhou.jpg

　つまり、アタッカーが暗号文を手に入れた状態から平文を推測成功する確率と、
何も手に入れない状態から平文を推測成功する確率が一致すれば、情報理論的に
安全ということです。つまりアタッカーは暗号文を手に入れても、平文に関する
情報を何も得ていることにならないということです。
　よって（3）示したいことは次が成り立つことになります。

Pr(M=(m_1,m_2))=Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))

　ここで平文は一様分布していていることに注意しておきましょう。そうすると
左辺は次のように求めることができます。

Pr(M=(m_1,m_2))=Pr(M=m_1,M=m_2)=(1/2^n)・(1/2^n)

　一方、右辺は（2）より次が成り立つことはすでに判明しています。

Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))=(1/2^n)・(1/2^n)

　よって確率が等しくなったので、情報理論的に安全であることが示せました。

　次に（4）を考えます。
　E_kは置換でctr+1≠ctr+2なので、E_k(ctr+1)≠E_k(ctr+2)となります。これは
置換の性質から明らかです。置換の性質上、違う値を入れて置換すると、その結
果も異なることになります。E_k(ctr+1)≠E_k(ctr+2)ということは、（1）から右
辺と左辺を書き換えることができて、c_1+m_1≠c_2+m_2になります。

　次のように2つに場合分けができます。

[1]c_1+m_1=c_2+m_2のとき

Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))
=Pr(E_k(ctr+1)=c_1+m_1,E_k(ctr+2)=c_2+m_2)　（∵（1））
=Pr(E_k(ctr+1)=c_1+m_1)・Pr(E_k(ctr+2)=c_2+m_2)　
=(1/2^n)・(1/(2^n-1))

　再度の式変形には注意してください。前半部で総パターンの2^n通りのうちから
ひとつが決定したので、後半部では総パターンから1を引いたもの総パターンにな
ります。図にすると次のようになります。

（図）http://s-akademeia.sakura.ne.jp/main/image9/ctr_keisan.jpg

[2]c_1+m_1≠c_2+m_2のとき

Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))
=0

　最後に（5）を考えます。今度は（3）のようにランダム関数族ではなく、ラン
ダム置換族を使う場合です。本当の暗号ではこんなことはしませんが、あくまで
理解を確かめるためにあえてランダム置換族にするということです。このように
条件を若干変更して、結果がどう変わってくるのかを自分で確かめるということ
は非常にためになります。暗号の仕様だけを追いかけていても何にもなりません。
　この暗号が情報理論的に安全であるには次が成り立たなければなりません。

∀c∈C,∀m∈M；Pr(M=(m_1,m_2)|C=(ctr,c_1,c_2))=Pr(M=(m_1,m_2))

　しかし、（4）から必ずしも成り立たないので（場合分けの結果が異なっている
ので明らか）、情報理論的に安全でないことになります。

　少し解説が長くなってしまいましたが、どうでしたでしょうか？　それほど難
しい数学などは使っていません。あくまで「情報理論的に安全」「関数と置換の
違い」「ビット列がある特定のビット列に一致するときの確率の求め方」の3つを
しっかり理解しておけば、類似問題は完璧に解けることになることでしょう。あ
まりこの辺の話をしっかり書いている本が少ないので（書いてあっても文字列ば
かりで抽象的過ぎたりする）、ここはしっかり理解しておいて欲しいと思います。
それでも理解できないとしても、以降の話がわからないということではないので
安心してください。。


■0x03.) CBCモード

　CBC（Cipher Block Chaining：暗号ブロック連鎖）モードとは、次の仕様にし
たがい各m_iを暗号化する方式です。

[1]暗号化

　平文M=(m_1,…,m_t)に対して、nビットの初期化ベクトルIV（Initial Value）
をランダムに選び、c_1=E_k(IV+m_1),c_2=E_k(c_1+m_2),…,c_t=E_k(c_t-1+m_t)
を計算して、暗号文をC=(c_1,…,c_t)とします。

[2]復号

　暗号文C=(IV,c_1,…,c_t)に対して、m_1=D_k(c_1)+IV,m_2=D_k(c_2)+c_1,…,m
_t=D_k(c_t)+c_t-1を計算して、平文をM=(m_1,…,m_t)とします。

（図）http://s-akademeia.sakura.ne.jp/main/image9/cbc.jpg

　mとcでE_kを挟んだような仕組みになっています。このE_kがなければ一種の関
数と見れます。

　特徴としてIVを定数（ブロック暗号の処理を施す度に）とすると安全でなくな
ります。IVを定数にしてしまうと、ある平文を決まった鍵で暗号化したときと同
じになってしまい、いつも暗号文が同じになってしまいます。例えばアタッカー
がターゲットの通信路をずっと監視していたとします。そのとき同じ暗号文が1週
間ごとの決まった時間に傍受したとします。通常規則性のある時間に同じ暗号文
が流れてくる確率はほとんどありません。それにも関わらずそのような規則性が
あるということは、同じ平文を通信していて、しかもそれに対応する暗号文が同
じになってしまうという欠陥のある暗号を利用していると推測できます。後はこ
の情報からどんどん情報が漏れていく可能性があります。
　またIVをカウンターモードにおけるctrのようにインクリメントするような設計
にしてもなりません。これも同様に考えればよいわけなので、最後に宿題として
います。


■0x04.) CFBモード

　CFB（Cipher Feed Back：暗号フィードバック）モードとは、次の仕様にしたが
い各m_iを暗号化する方式です。

[1]暗号化

　平文M=(m_1,…,m_t)に対して、nビットの初期化ベクトルIV（Initial Value）
をランダムに選び、c_1=m_1+E_k(IV),c_2=m_2+E_k(c_1),…,c_t=m_t+E_k(c_t-1)
を計算して、暗号文をC=(c_1,…,c_t)とします。

[2]復号

　暗号文C=(IV,c_1,…,c_t)に対して、m_1=c_1+E_k(IV),m_2=c_2+E_k(c_1),…,m
_t=c_t+E_k(c_t-1)を計算して、平文をM=(m_1,…,m_t)とします。復号アルゴリズ
ムD_kではないことに注意。

（図）http://s-akademeia.sakura.ne.jp/main/image9/cfb.jpg

　図から平文ブロックは暗号アルゴリズムによって直接暗号化されないというこ
とがわかります。
　CFBモードで暗号アルゴリズムが生成するビット列のことを鍵ストリームと呼び
ます。CFBモードでは鍵ストリームを生成するための擬似乱数生成器として暗号ア
ルゴリズムを用いています。IVは擬似乱数生成器の種に相当します。
　なおE_kは置換である必要がありません。


■0x05.) OFBモード

　OFB（Output Feed Back：暗号フィードバック）モードとは、次の仕様にしたが
い各m_iを暗号化する方式です。

[1]暗号化

　平文M=(m_1,…,m_t)に対して、nビットの初期化ベクトルIV（Initial Value）
をランダムに選び、
z_1=E_k(IV),z_2=E_k(z_1),…,z_t=E_k(z_t-1)
c_1=m_1+z_1,c_2=m_2+z_2,…c_t=m_t+z_t
を計算して、暗号文をC=(c_1,…,c_t)とします。

[2]復号

　暗号文C=(IV,c_1,…,c_t)に対して、
z_1=E_k(IV),z_2=E_k(z_1),…,z_t=E_k(z_t-1)
m_1=c_1+z_1,m_2=c_2+z_2,…,m_t=c_t+z_t
を計算して、平文をM=(m_1,…,m_t)とします。復号アルゴリズムD_kではないこと
に注意。

（図）http://s-akademeia.sakura.ne.jp/main/image9/ofb.jpg

　図から平文ブロックは暗号アルゴリズムによって直接暗号化されないというこ
とがわかります。平文ブロックと暗号アルゴリズムの出力とをXOR演算して、暗号
ブロックを作り出します。OFBモードはこの点でCFBモードに似ています。
　IVは暗号化の度ごとに異なるランダムビット列を用いるのが普通です。
　なおE_kは置換である必要がありません。

■0x06.) 各種利用モードの比較

　以上でブロック暗号の主要な利用モードのすべての解説が終りました。

　実際にブロック暗号を設計するときはCBCモード・CTRモードの使用が推奨され
ています。実際にインターネットではCBCモードがよく登場しています。

　最後に関連する定理を少しだけ紹介します。この定理の証明は余力のある方だ
けで十分だと思います。

[定理]
ECBモード以外の各モードは、{E_k}が擬似ランダム置換族であると仮定すると、
選択平文攻撃に対して安全である。

[定理]
CTRモードが最も安全である。


■0x07.) 宿題

　今回の解説したことを理解したかを確認のために、宿題として2つの問題を示し
ておきます。

問：次の設問を解け。
（1）CFBモードで、IVをカウンターモードにおけるctrのようにインクリメントす
るような設計にするとどのような問題が発生するか？
（2）CFBモードでは暗号化の度ごとに異なるランダムビット列を用いなければ安
全ではありません。一方OFBモードでは暗号化の度ごとに異なるランダムビット列
を用いるのが普通と言及しました。そこで実際にOFBモードではどのような問題が
発生するか？


■0x08.) おわりに

　次回はブロック型の最大の特徴であるFeistal型構造について解説する予定です。

　最後に少し宣伝。現在アカデメイアではSASというオンラインゼミを開催してい
ます。

http://akademeia.info/index.php?SAS2006

　現在行っている題材はグラフ理論ですが、ネットワーク理論や暗号理論などあ
らゆる分野に係わってきます。真面目に習得しようという意欲のある方は是非メ
ールでお知らせください。もちろん現段階の数学の能力はゼロでもまったく問題
ありません。実際に高校生なども参加しています。気軽に声をかけてください。

　それでは来月会いましょう。

